{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.StompJs = {}));\n})(this, function (exports) {\n  'use strict';\n\n  /**\n   * @internal\n   */\n  function augmentWebsocket(webSocket, debug) {\n    webSocket.terminate = function () {\n      const noOp = () => {};\n      // set all callbacks to no op\n      this.onerror = noOp;\n      this.onmessage = noOp;\n      this.onopen = noOp;\n      const ts = new Date();\n      const id = Math.random().toString().substring(2, 8); // A simulated id\n      const origOnClose = this.onclose;\n      // Track delay in actual closure of the socket\n      this.onclose = closeEvent => {\n        const delay = new Date().getTime() - ts.getTime();\n        debug(`Discarded socket (#${id})  closed after ${delay}ms, with code/reason: ${closeEvent.code}/${closeEvent.reason}`);\n      };\n      this.close();\n      origOnClose?.call(webSocket, {\n        code: 4001,\n        reason: `Quick discarding socket (#${id}) without waiting for the shutdown sequence.`,\n        wasClean: false\n      });\n    };\n  }\n\n  /**\n   * Some byte values, used as per STOMP specifications.\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  const BYTE = {\n    // LINEFEED byte (octet 10)\n    LF: '\\x0A',\n    // NULL byte (octet 0)\n    NULL: '\\x00'\n  };\n\n  /**\n   * Frame class represents a STOMP frame.\n   *\n   * @internal\n   */\n  class FrameImpl {\n    /**\n     * body of the frame\n     */\n    get body() {\n      if (!this._body && this.isBinaryBody) {\n        this._body = new TextDecoder().decode(this._binaryBody);\n      }\n      return this._body || '';\n    }\n    /**\n     * body as Uint8Array\n     */\n    get binaryBody() {\n      if (!this._binaryBody && !this.isBinaryBody) {\n        this._binaryBody = new TextEncoder().encode(this._body);\n      }\n      // At this stage it will definitely have a valid value\n      return this._binaryBody;\n    }\n    /**\n     * Frame constructor. `command`, `headers` and `body` are available as properties.\n     *\n     * @internal\n     */\n    constructor(params) {\n      const {\n        command,\n        headers,\n        body,\n        binaryBody,\n        escapeHeaderValues,\n        skipContentLengthHeader\n      } = params;\n      this.command = command;\n      this.headers = Object.assign({}, headers || {});\n      if (binaryBody) {\n        this._binaryBody = binaryBody;\n        this.isBinaryBody = true;\n      } else {\n        this._body = body || '';\n        this.isBinaryBody = false;\n      }\n      this.escapeHeaderValues = escapeHeaderValues || false;\n      this.skipContentLengthHeader = skipContentLengthHeader || false;\n    }\n    /**\n     * deserialize a STOMP Frame from raw data.\n     *\n     * @internal\n     */\n    static fromRawFrame(rawFrame, escapeHeaderValues) {\n      const headers = {};\n      const trim = str => str.replace(/^\\s+|\\s+$/g, '');\n      // In case of repeated headers, as per standards, first value need to be used\n      for (const header of rawFrame.headers.reverse()) {\n        header.indexOf(':');\n        const key = trim(header[0]);\n        let value = trim(header[1]);\n        if (escapeHeaderValues && rawFrame.command !== 'CONNECT' && rawFrame.command !== 'CONNECTED') {\n          value = FrameImpl.hdrValueUnEscape(value);\n        }\n        headers[key] = value;\n      }\n      return new FrameImpl({\n        command: rawFrame.command,\n        headers,\n        binaryBody: rawFrame.binaryBody,\n        escapeHeaderValues\n      });\n    }\n    /**\n     * @internal\n     */\n    toString() {\n      return this.serializeCmdAndHeaders();\n    }\n    /**\n     * serialize this Frame in a format suitable to be passed to WebSocket.\n     * If the body is string the output will be string.\n     * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n     *\n     * @internal\n     */\n    serialize() {\n      const cmdAndHeaders = this.serializeCmdAndHeaders();\n      if (this.isBinaryBody) {\n        return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n      } else {\n        return cmdAndHeaders + this._body + BYTE.NULL;\n      }\n    }\n    serializeCmdAndHeaders() {\n      const lines = [this.command];\n      if (this.skipContentLengthHeader) {\n        delete this.headers['content-length'];\n      }\n      for (const name of Object.keys(this.headers || {})) {\n        const value = this.headers[name];\n        if (this.escapeHeaderValues && this.command !== 'CONNECT' && this.command !== 'CONNECTED') {\n          lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\n        } else {\n          lines.push(`${name}:${value}`);\n        }\n      }\n      if (this.isBinaryBody || !this.isBodyEmpty() && !this.skipContentLengthHeader) {\n        lines.push(`content-length:${this.bodyLength()}`);\n      }\n      return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n    }\n    isBodyEmpty() {\n      return this.bodyLength() === 0;\n    }\n    bodyLength() {\n      const binaryBody = this.binaryBody;\n      return binaryBody ? binaryBody.length : 0;\n    }\n    /**\n     * Compute the size of a UTF-8 string by counting its number of bytes\n     * (and not the number of characters composing the string)\n     */\n    static sizeOfUTF8(s) {\n      return s ? new TextEncoder().encode(s).length : 0;\n    }\n    static toUnit8Array(cmdAndHeaders, binaryBody) {\n      const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n      const nullTerminator = new Uint8Array([0]);\n      const uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n      uint8Frame.set(uint8CmdAndHeaders);\n      uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n      uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n      return uint8Frame;\n    }\n    /**\n     * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n     *\n     * @internal\n     */\n    static marshall(params) {\n      const frame = new FrameImpl(params);\n      return frame.serialize();\n    }\n    /**\n     *  Escape header values\n     */\n    static hdrValueEscape(str) {\n      return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/:/g, '\\\\c');\n    }\n    /**\n     * UnEscape header values\n     */\n    static hdrValueUnEscape(str) {\n      return str.replace(/\\\\r/g, '\\r').replace(/\\\\n/g, '\\n').replace(/\\\\c/g, ':').replace(/\\\\\\\\/g, '\\\\');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  const NULL = 0;\n  /**\n   * @internal\n   */\n  const LF = 10;\n  /**\n   * @internal\n   */\n  const CR = 13;\n  /**\n   * @internal\n   */\n  const COLON = 58;\n  /**\n   * This is an evented, rec descent parser.\n   * A stream of Octets can be passed and whenever it recognizes\n   * a complete Frame or an incoming ping it will invoke the registered callbacks.\n   *\n   * All incoming Octets are fed into _onByte function.\n   * Depending on current state the _onByte function keeps changing.\n   * Depending on the state it keeps accumulating into _token and _results.\n   * State is indicated by current value of _onByte, all states are named as _collect.\n   *\n   * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n   * imply that all lengths are considered in bytes (instead of string lengths).\n   * So, before actual parsing, if the incoming data is String it is converted to Octets.\n   * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n   *\n   * There is no peek function on the incoming data.\n   * When a state change occurs based on an Octet without consuming the Octet,\n   * the Octet, after state change, is fed again (_reinjectByte).\n   * This became possible as the state change can be determined by inspecting just one Octet.\n   *\n   * There are two modes to collect the body, if content-length header is there then it by counting Octets\n   * otherwise it is determined by NULL terminator.\n   *\n   * Following the standards, the command and headers are converted to Strings\n   * and the body is returned as Octets.\n   * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n   *\n   * This parser does not use Regular Expressions as that can only operate on Strings.\n   *\n   * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n   * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n   * is pushed.\n   *\n   * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n   * (which is protocol version specific), and convert body to text.\n   *\n   * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  class Parser {\n    constructor(onFrame, onIncomingPing) {\n      this.onFrame = onFrame;\n      this.onIncomingPing = onIncomingPing;\n      this._encoder = new TextEncoder();\n      this._decoder = new TextDecoder();\n      this._token = [];\n      this._initState();\n    }\n    parseChunk(segment, appendMissingNULLonIncoming = false) {\n      let chunk;\n      if (typeof segment === 'string') {\n        chunk = this._encoder.encode(segment);\n      } else {\n        chunk = new Uint8Array(segment);\n      }\n      // See https://github.com/stomp-js/stompjs/issues/89\n      // Remove when underlying issue is fixed.\n      //\n      // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n      if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n        const chunkWithNull = new Uint8Array(chunk.length + 1);\n        chunkWithNull.set(chunk, 0);\n        chunkWithNull[chunk.length] = 0;\n        chunk = chunkWithNull;\n      }\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < chunk.length; i++) {\n        const byte = chunk[i];\n        this._onByte(byte);\n      }\n    }\n    // The following implements a simple Rec Descent Parser.\n    // The grammar is simple and just one byte tells what should be the next state\n    _collectFrame(byte) {\n      if (byte === NULL) {\n        // Ignore\n        return;\n      }\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        // Incoming Ping\n        this.onIncomingPing();\n        return;\n      }\n      this._onByte = this._collectCommand;\n      this._reinjectByte(byte);\n    }\n    _collectCommand(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._results.command = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaders;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _collectHeaders(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._setupCollectBody();\n        return;\n      }\n      this._onByte = this._collectHeaderKey;\n      this._reinjectByte(byte);\n    }\n    _reinjectByte(byte) {\n      this._onByte(byte);\n    }\n    _collectHeaderKey(byte) {\n      if (byte === COLON) {\n        this._headerKey = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaderValue;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _collectHeaderValue(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n        this._headerKey = undefined;\n        this._onByte = this._collectHeaders;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _setupCollectBody() {\n      const contentLengthHeader = this._results.headers.filter(header => {\n        return header[0] === 'content-length';\n      })[0];\n      if (contentLengthHeader) {\n        this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n        this._onByte = this._collectBodyFixedSize;\n      } else {\n        this._onByte = this._collectBodyNullTerminated;\n      }\n    }\n    _collectBodyNullTerminated(byte) {\n      if (byte === NULL) {\n        this._retrievedBody();\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _collectBodyFixedSize(byte) {\n      // It is post decrement, so that we discard the trailing NULL octet\n      if (this._bodyBytesRemaining-- === 0) {\n        this._retrievedBody();\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _retrievedBody() {\n      this._results.binaryBody = this._consumeTokenAsRaw();\n      try {\n        this.onFrame(this._results);\n      } catch (e) {\n        console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n      }\n      this._initState();\n    }\n    // Rec Descent Parser helpers\n    _consumeByte(byte) {\n      this._token.push(byte);\n    }\n    _consumeTokenAsUTF8() {\n      return this._decoder.decode(this._consumeTokenAsRaw());\n    }\n    _consumeTokenAsRaw() {\n      const rawResult = new Uint8Array(this._token);\n      this._token = [];\n      return rawResult;\n    }\n    _initState() {\n      this._results = {\n        command: undefined,\n        headers: [],\n        binaryBody: undefined\n      };\n      this._token = [];\n      this._headerKey = undefined;\n      this._onByte = this._collectFrame;\n    }\n  }\n\n  /**\n   * Possible states for the IStompSocket\n   */\n  exports.StompSocketState = void 0;\n  (function (StompSocketState) {\n    StompSocketState[StompSocketState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    StompSocketState[StompSocketState[\"OPEN\"] = 1] = \"OPEN\";\n    StompSocketState[StompSocketState[\"CLOSING\"] = 2] = \"CLOSING\";\n    StompSocketState[StompSocketState[\"CLOSED\"] = 3] = \"CLOSED\";\n  })(exports.StompSocketState || (exports.StompSocketState = {}));\n  /**\n   * Possible activation state\n   */\n  exports.ActivationState = void 0;\n  (function (ActivationState) {\n    ActivationState[ActivationState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    ActivationState[ActivationState[\"DEACTIVATING\"] = 1] = \"DEACTIVATING\";\n    ActivationState[ActivationState[\"INACTIVE\"] = 2] = \"INACTIVE\";\n  })(exports.ActivationState || (exports.ActivationState = {}));\n  /**\n   * Possible reconnection wait time modes\n   */\n  exports.ReconnectionTimeMode = void 0;\n  (function (ReconnectionTimeMode) {\n    ReconnectionTimeMode[ReconnectionTimeMode[\"LINEAR\"] = 0] = \"LINEAR\";\n    ReconnectionTimeMode[ReconnectionTimeMode[\"EXPONENTIAL\"] = 1] = \"EXPONENTIAL\";\n  })(exports.ReconnectionTimeMode || (exports.ReconnectionTimeMode = {}));\n  /**\n   * Possible ticker strategies for outgoing heartbeat ping\n   */\n  exports.TickerStrategy = void 0;\n  (function (TickerStrategy) {\n    TickerStrategy[\"Interval\"] = \"interval\";\n    TickerStrategy[\"Worker\"] = \"worker\";\n  })(exports.TickerStrategy || (exports.TickerStrategy = {}));\n  class Ticker {\n    constructor(_interval, _strategy = exports.TickerStrategy.Interval, _debug) {\n      this._interval = _interval;\n      this._strategy = _strategy;\n      this._debug = _debug;\n      this._workerScript = `\n    var startTime = Date.now();\n    setInterval(function() {\n        self.postMessage(Date.now() - startTime);\n    }, ${this._interval});\n  `;\n    }\n    start(tick) {\n      this.stop();\n      if (this.shouldUseWorker()) {\n        this.runWorker(tick);\n      } else {\n        this.runInterval(tick);\n      }\n    }\n    stop() {\n      this.disposeWorker();\n      this.disposeInterval();\n    }\n    shouldUseWorker() {\n      return typeof Worker !== 'undefined' && this._strategy === exports.TickerStrategy.Worker;\n    }\n    runWorker(tick) {\n      this._debug('Using runWorker for outgoing pings');\n      if (!this._worker) {\n        this._worker = new Worker(URL.createObjectURL(new Blob([this._workerScript], {\n          type: 'text/javascript'\n        })));\n        this._worker.onmessage = message => tick(message.data);\n      }\n    }\n    runInterval(tick) {\n      this._debug('Using runInterval for outgoing pings');\n      if (!this._timer) {\n        const startTime = Date.now();\n        this._timer = setInterval(() => {\n          tick(Date.now() - startTime);\n        }, this._interval);\n      }\n    }\n    disposeWorker() {\n      if (this._worker) {\n        this._worker.terminate();\n        delete this._worker;\n        this._debug('Outgoing ping disposeWorker');\n      }\n    }\n    disposeInterval() {\n      if (this._timer) {\n        clearInterval(this._timer);\n        delete this._timer;\n        this._debug('Outgoing ping disposeInterval');\n      }\n    }\n  }\n\n  /**\n   * Supported STOMP versions\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class Versions {\n    /**\n     * Takes an array of versions, typical elements '1.2', '1.1', or '1.0'\n     *\n     * You will be creating an instance of this class if you want to override\n     * supported versions to be declared during STOMP handshake.\n     */\n    constructor(versions) {\n      this.versions = versions;\n    }\n    /**\n     * Used as part of CONNECT STOMP Frame\n     */\n    supportedVersions() {\n      return this.versions.join(',');\n    }\n    /**\n     * Used while creating a WebSocket\n     */\n    protocolVersions() {\n      return this.versions.map(x => `v${x.replace('.', '')}.stomp`);\n    }\n  }\n  /**\n   * Indicates protocol version 1.0\n   */\n  Versions.V1_0 = '1.0';\n  /**\n   * Indicates protocol version 1.1\n   */\n  Versions.V1_1 = '1.1';\n  /**\n   * Indicates protocol version 1.2\n   */\n  Versions.V1_2 = '1.2';\n  /**\n   * @internal\n   */\n  Versions.default = new Versions([Versions.V1_2, Versions.V1_1, Versions.V1_0]);\n\n  /**\n   * The STOMP protocol handler\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  class StompHandler {\n    get connectedVersion() {\n      return this._connectedVersion;\n    }\n    get connected() {\n      return this._connected;\n    }\n    constructor(_client, _webSocket, config) {\n      this._client = _client;\n      this._webSocket = _webSocket;\n      this._connected = false;\n      this._serverFrameHandlers = {\n        // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n        CONNECTED: frame => {\n          this.debug(`connected to server ${frame.headers.server}`);\n          this._connected = true;\n          this._connectedVersion = frame.headers.version;\n          // STOMP version 1.2 needs header values to be escaped\n          if (this._connectedVersion === Versions.V1_2) {\n            this._escapeHeaderValues = true;\n          }\n          this._setupHeartbeat(frame.headers);\n          this.onConnect(frame);\n        },\n        // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n        MESSAGE: frame => {\n          // the callback is registered when the client calls\n          // `subscribe()`.\n          // If there is no registered subscription for the received message,\n          // the default `onUnhandledMessage` callback is used that the client can set.\n          // This is useful for subscriptions that are automatically created\n          // on the browser side (e.g. [RabbitMQ's temporary\n          // queues](https://www.rabbitmq.com/stomp.html)).\n          const subscription = frame.headers.subscription;\n          const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n          // bless the frame to be a Message\n          const message = frame;\n          const client = this;\n          const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id'];\n          // add `ack()` and `nack()` methods directly to the returned frame\n          // so that a simple call to `message.ack()` can acknowledge the message.\n          message.ack = (headers = {}) => {\n            return client.ack(messageId, subscription, headers);\n          };\n          message.nack = (headers = {}) => {\n            return client.nack(messageId, subscription, headers);\n          };\n          onReceive(message);\n        },\n        // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n        RECEIPT: frame => {\n          const callback = this._receiptWatchers[frame.headers['receipt-id']];\n          if (callback) {\n            callback(frame);\n            // Server will acknowledge only once, remove the callback\n            delete this._receiptWatchers[frame.headers['receipt-id']];\n          } else {\n            this.onUnhandledReceipt(frame);\n          }\n        },\n        // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n        ERROR: frame => {\n          this.onStompError(frame);\n        }\n      };\n      // used to index subscribers\n      this._counter = 0;\n      // subscription callbacks indexed by subscriber's ID\n      this._subscriptions = {};\n      // receipt-watchers indexed by receipts-ids\n      this._receiptWatchers = {};\n      this._partialData = '';\n      this._escapeHeaderValues = false;\n      this._lastServerActivityTS = Date.now();\n      this.debug = config.debug;\n      this.stompVersions = config.stompVersions;\n      this.connectHeaders = config.connectHeaders;\n      this.disconnectHeaders = config.disconnectHeaders;\n      this.heartbeatIncoming = config.heartbeatIncoming;\n      this.heartbeatOutgoing = config.heartbeatOutgoing;\n      this.splitLargeFrames = config.splitLargeFrames;\n      this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n      this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n      this.logRawCommunication = config.logRawCommunication;\n      this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n      this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n      this.onConnect = config.onConnect;\n      this.onDisconnect = config.onDisconnect;\n      this.onStompError = config.onStompError;\n      this.onWebSocketClose = config.onWebSocketClose;\n      this.onWebSocketError = config.onWebSocketError;\n      this.onUnhandledMessage = config.onUnhandledMessage;\n      this.onUnhandledReceipt = config.onUnhandledReceipt;\n      this.onUnhandledFrame = config.onUnhandledFrame;\n    }\n    start() {\n      const parser = new Parser(\n      // On Frame\n      rawFrame => {\n        const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n        if (!this.logRawCommunication) {\n          this.debug(`<<< ${frame}`);\n        }\n        const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n        serverFrameHandler(frame);\n      },\n      // On Incoming Ping\n      () => {\n        this.debug('<<< PONG');\n      });\n      this._webSocket.onmessage = evt => {\n        this.debug('Received data');\n        this._lastServerActivityTS = Date.now();\n        if (this.logRawCommunication) {\n          const rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n          this.debug(`<<< ${rawChunkAsString}`);\n        }\n        parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n      };\n      this._webSocket.onclose = closeEvent => {\n        this.debug(`Connection closed to ${this._webSocket.url}`);\n        this._cleanUp();\n        this.onWebSocketClose(closeEvent);\n      };\n      this._webSocket.onerror = errorEvent => {\n        this.onWebSocketError(errorEvent);\n      };\n      this._webSocket.onopen = () => {\n        // Clone before updating\n        const connectHeaders = Object.assign({}, this.connectHeaders);\n        this.debug('Web Socket Opened...');\n        connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n        connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n        this._transmit({\n          command: 'CONNECT',\n          headers: connectHeaders\n        });\n      };\n    }\n    _setupHeartbeat(headers) {\n      if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n        return;\n      }\n      // It is valid for the server to not send this header\n      // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n      if (!headers['heart-beat']) {\n        return;\n      }\n      // heart-beat header received from the server looks like:\n      //\n      //     heart-beat: sx, sy\n      const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map(v => parseInt(v, 10));\n      if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n        const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n        this.debug(`send PING every ${ttl}ms`);\n        this._pinger = new Ticker(ttl, this._client.heartbeatStrategy, this.debug);\n        this._pinger.start(() => {\n          if (this._webSocket.readyState === exports.StompSocketState.OPEN) {\n            this._webSocket.send(BYTE.LF);\n            this.debug('>>> PING');\n          }\n        });\n      }\n      if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n        const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n        this.debug(`check PONG every ${ttl}ms`);\n        this._ponger = setInterval(() => {\n          const delta = Date.now() - this._lastServerActivityTS;\n          // We wait twice the TTL to be flexible on window's setInterval calls\n          if (delta > ttl * 2) {\n            this.debug(`did not receive server activity for the last ${delta}ms`);\n            this._closeOrDiscardWebsocket();\n          }\n        }, ttl);\n      }\n    }\n    _closeOrDiscardWebsocket() {\n      if (this.discardWebsocketOnCommFailure) {\n        this.debug('Discarding websocket, the underlying socket may linger for a while');\n        this.discardWebsocket();\n      } else {\n        this.debug('Issuing close on the websocket');\n        this._closeWebsocket();\n      }\n    }\n    forceDisconnect() {\n      if (this._webSocket) {\n        if (this._webSocket.readyState === exports.StompSocketState.CONNECTING || this._webSocket.readyState === exports.StompSocketState.OPEN) {\n          this._closeOrDiscardWebsocket();\n        }\n      }\n    }\n    _closeWebsocket() {\n      this._webSocket.onmessage = () => {}; // ignore messages\n      this._webSocket.close();\n    }\n    discardWebsocket() {\n      if (typeof this._webSocket.terminate !== 'function') {\n        augmentWebsocket(this._webSocket, msg => this.debug(msg));\n      }\n      // @ts-ignore - this method will be there at this stage\n      this._webSocket.terminate();\n    }\n    _transmit(params) {\n      const {\n        command,\n        headers,\n        body,\n        binaryBody,\n        skipContentLengthHeader\n      } = params;\n      const frame = new FrameImpl({\n        command,\n        headers,\n        body,\n        binaryBody,\n        escapeHeaderValues: this._escapeHeaderValues,\n        skipContentLengthHeader\n      });\n      let rawChunk = frame.serialize();\n      if (this.logRawCommunication) {\n        this.debug(`>>> ${rawChunk}`);\n      } else {\n        this.debug(`>>> ${frame}`);\n      }\n      if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n        rawChunk = new TextEncoder().encode(rawChunk);\n      }\n      if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n        this._webSocket.send(rawChunk);\n      } else {\n        let out = rawChunk;\n        while (out.length > 0) {\n          const chunk = out.substring(0, this.maxWebSocketChunkSize);\n          out = out.substring(this.maxWebSocketChunkSize);\n          this._webSocket.send(chunk);\n          this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n        }\n      }\n    }\n    dispose() {\n      if (this.connected) {\n        try {\n          // clone before updating\n          const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n          if (!disconnectHeaders.receipt) {\n            disconnectHeaders.receipt = `close-${this._counter++}`;\n          }\n          this.watchForReceipt(disconnectHeaders.receipt, frame => {\n            this._closeWebsocket();\n            this._cleanUp();\n            this.onDisconnect(frame);\n          });\n          this._transmit({\n            command: 'DISCONNECT',\n            headers: disconnectHeaders\n          });\n        } catch (error) {\n          this.debug(`Ignoring error during disconnect ${error}`);\n        }\n      } else {\n        if (this._webSocket.readyState === exports.StompSocketState.CONNECTING || this._webSocket.readyState === exports.StompSocketState.OPEN) {\n          this._closeWebsocket();\n        }\n      }\n    }\n    _cleanUp() {\n      this._connected = false;\n      if (this._pinger) {\n        this._pinger.stop();\n        this._pinger = undefined;\n      }\n      if (this._ponger) {\n        clearInterval(this._ponger);\n        this._ponger = undefined;\n      }\n    }\n    publish(params) {\n      const {\n        destination,\n        headers,\n        body,\n        binaryBody,\n        skipContentLengthHeader\n      } = params;\n      const hdrs = Object.assign({\n        destination\n      }, headers);\n      this._transmit({\n        command: 'SEND',\n        headers: hdrs,\n        body,\n        binaryBody,\n        skipContentLengthHeader\n      });\n    }\n    watchForReceipt(receiptId, callback) {\n      this._receiptWatchers[receiptId] = callback;\n    }\n    subscribe(destination, callback, headers = {}) {\n      headers = Object.assign({}, headers);\n      if (!headers.id) {\n        headers.id = `sub-${this._counter++}`;\n      }\n      headers.destination = destination;\n      this._subscriptions[headers.id] = callback;\n      this._transmit({\n        command: 'SUBSCRIBE',\n        headers\n      });\n      const client = this;\n      return {\n        id: headers.id,\n        unsubscribe(hdrs) {\n          return client.unsubscribe(headers.id, hdrs);\n        }\n      };\n    }\n    unsubscribe(id, headers = {}) {\n      headers = Object.assign({}, headers);\n      delete this._subscriptions[id];\n      headers.id = id;\n      this._transmit({\n        command: 'UNSUBSCRIBE',\n        headers\n      });\n    }\n    begin(transactionId) {\n      const txId = transactionId || `tx-${this._counter++}`;\n      this._transmit({\n        command: 'BEGIN',\n        headers: {\n          transaction: txId\n        }\n      });\n      const client = this;\n      return {\n        id: txId,\n        commit() {\n          client.commit(txId);\n        },\n        abort() {\n          client.abort(txId);\n        }\n      };\n    }\n    commit(transactionId) {\n      this._transmit({\n        command: 'COMMIT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n    abort(transactionId) {\n      this._transmit({\n        command: 'ABORT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n    ack(messageId, subscriptionId, headers = {}) {\n      headers = Object.assign({}, headers);\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n      headers.subscription = subscriptionId;\n      this._transmit({\n        command: 'ACK',\n        headers\n      });\n    }\n    nack(messageId, subscriptionId, headers = {}) {\n      headers = Object.assign({}, headers);\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n      headers.subscription = subscriptionId;\n      return this._transmit({\n        command: 'NACK',\n        headers\n      });\n    }\n  }\n\n  /**\n   * STOMP Client Class.\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class Client {\n    /**\n     * Underlying WebSocket instance, READONLY.\n     */\n    get webSocket() {\n      return this._stompHandler?._webSocket;\n    }\n    /**\n     * Disconnection headers.\n     */\n    get disconnectHeaders() {\n      return this._disconnectHeaders;\n    }\n    set disconnectHeaders(value) {\n      this._disconnectHeaders = value;\n      if (this._stompHandler) {\n        this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n      }\n    }\n    /**\n     * `true` if there is an active connection to STOMP Broker\n     */\n    get connected() {\n      return !!this._stompHandler && this._stompHandler.connected;\n    }\n    /**\n     * version of STOMP protocol negotiated with the server, READONLY\n     */\n    get connectedVersion() {\n      return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n    }\n    /**\n     * if the client is active (connected or going to reconnect)\n     */\n    get active() {\n      return this.state === exports.ActivationState.ACTIVE;\n    }\n    _changeState(state) {\n      this.state = state;\n      this.onChangeState(state);\n    }\n    /**\n     * Create an instance.\n     */\n    constructor(conf = {}) {\n      /**\n       * STOMP versions to attempt during STOMP handshake. By default, versions `1.2`, `1.1`, and `1.0` are attempted.\n       *\n       * Example:\n       * ```javascript\n       *        // Try only versions 1.1 and 1.0\n       *        client.stompVersions = new Versions(['1.1', '1.0'])\n       * ```\n       */\n      this.stompVersions = Versions.default;\n      /**\n       * Will retry if Stomp connection is not established in specified milliseconds.\n       * Default 0, which switches off automatic reconnection.\n       */\n      this.connectionTimeout = 0;\n      /**\n       *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n       */\n      this.reconnectDelay = 5000;\n      /**\n       * tracking the time to the next reconnection. Initialized to [Client#reconnectDelay]{@link Client#reconnectDelay}'s value and it may\n       * change depending on the [Client#reconnectTimeMode]{@link Client#reconnectTimeMode} setting\n       */\n      this._nextReconnectDelay = 0;\n      /**\n       * Maximum time to wait between reconnects, in milliseconds. Defaults to 15 minutes.\n       * Only relevant when [Client#reconnectTimeMode]{@link Client#reconnectTimeMode} not LINEAR (e.g., EXPONENTIAL).\n       * Set to 0 for no limit on wait time.\n       */\n      this.maxReconnectDelay = 15 * 60 * 1000; // 15 minutes in ms\n      /**\n       * Reconnection wait time mode, either linear (default) or exponential.\n       * Note: See [Client#maxReconnectDelay]{@link Client#maxReconnectDelay} for setting the maximum delay when exponential\n       *\n       * ```javascript\n       * client.configure({\n       *   reconnectTimeMode: ReconnectionTimeMode.EXPONENTIAL,\n       *   reconnectDelay: 200, // It will wait 200, 400, 800 ms...\n       *   maxReconnectDelay: 10000, // Optional, when provided, it will not wait more that these ms\n       * })\n       * ```\n       */\n      this.reconnectTimeMode = exports.ReconnectionTimeMode.LINEAR;\n      /**\n       * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n       */\n      this.heartbeatIncoming = 10000;\n      /**\n       * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n       */\n      this.heartbeatOutgoing = 10000;\n      /**\n       * Outgoing heartbeat strategy.\n       * See https://github.com/stomp-js/stompjs/pull/579\n       *\n       * Can be worker or interval strategy, but will always use `interval`\n       * if web workers are unavailable, for example, in a non-browser environment.\n       *\n       * Using Web Workers may work better on long-running pages\n       * and mobile apps, as the browser may suspend Timers in the main page.\n       * Try the `Worker` mode if you discover disconnects when the browser tab is in the background.\n       *\n       * When used in a JS environment, use 'worker' or 'interval' as valid values.\n       *\n       * Defaults to `interval` strategy.\n       */\n      this.heartbeatStrategy = exports.TickerStrategy.Interval;\n      /**\n       * This switches on a non-standard behavior while sending WebSocket packets.\n       * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n       * Only Java Spring brokers seem to support this mode.\n       *\n       * WebSockets, by itself, split large (text) packets,\n       * so it is not needed with a truly compliant STOMP/WebSocket broker.\n       * Setting it for such a broker will cause large messages to fail.\n       *\n       * `false` by default.\n       *\n       * Binary frames are never split.\n       */\n      this.splitLargeFrames = false;\n      /**\n       * See [splitLargeFrames]{@link Client#splitLargeFrames}.\n       * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n       */\n      this.maxWebSocketChunkSize = 8 * 1024;\n      /**\n       * Usually the\n       * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\n       * is automatically decided by type of the payload.\n       * Default is `false`, which should work with all compliant brokers.\n       *\n       * Set this flag to force binary frames.\n       */\n      this.forceBinaryWSFrames = false;\n      /**\n       * A bug in ReactNative chops a string on occurrence of a NULL.\n       * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\n       * This makes incoming WebSocket messages invalid STOMP packets.\n       * Setting this flag attempts to reverse the damage by appending a NULL.\n       * If the broker splits a large message into multiple WebSocket messages,\n       * this flag will cause data loss and abnormal termination of connection.\n       *\n       * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\n       */\n      this.appendMissingNULLonIncoming = false;\n      /**\n       * Browsers do not immediately close WebSockets when `.close` is issued.\n       * This may cause reconnection to take a significantly long time in case\n       *  of some types of failures.\n       * In case of incoming heartbeat failure, this experimental flag instructs\n       * the library to discard the socket immediately\n       * (even before it is actually closed).\n       */\n      this.discardWebsocketOnCommFailure = false;\n      /**\n       * Activation state.\n       *\n       * It will usually be ACTIVE or INACTIVE.\n       * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n       */\n      this.state = exports.ActivationState.INACTIVE;\n      // No op callbacks\n      const noOp = () => {};\n      this.debug = noOp;\n      this.beforeConnect = noOp;\n      this.onConnect = noOp;\n      this.onDisconnect = noOp;\n      this.onUnhandledMessage = noOp;\n      this.onUnhandledReceipt = noOp;\n      this.onUnhandledFrame = noOp;\n      this.onStompError = noOp;\n      this.onWebSocketClose = noOp;\n      this.onWebSocketError = noOp;\n      this.logRawCommunication = false;\n      this.onChangeState = noOp;\n      // These parameters would typically get proper values before connect is called\n      this.connectHeaders = {};\n      this._disconnectHeaders = {};\n      // Apply configuration\n      this.configure(conf);\n    }\n    /**\n     * Update configuration.\n     */\n    configure(conf) {\n      // bulk assign all properties to this\n      Object.assign(this, conf);\n      // Warn on incorrect maxReconnectDelay settings\n      if (this.maxReconnectDelay > 0 && this.maxReconnectDelay < this.reconnectDelay) {\n        this.debug(`Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`);\n        this.maxReconnectDelay = this.reconnectDelay;\n      }\n    }\n    /**\n     * Initiate the connection with the broker.\n     * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n     * it will keep trying to reconnect. If the [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}\n     * is set to EXPONENTIAL it will increase the wait time exponentially\n     *\n     * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n     */\n    activate() {\n      const _activate = () => {\n        if (this.active) {\n          this.debug('Already ACTIVE, ignoring request to activate');\n          return;\n        }\n        this._changeState(exports.ActivationState.ACTIVE);\n        this._nextReconnectDelay = this.reconnectDelay;\n        this._connect();\n      };\n      // if it is deactivating, wait for it to complete before activating.\n      if (this.state === exports.ActivationState.DEACTIVATING) {\n        this.debug('Waiting for deactivation to finish before activating');\n        this.deactivate().then(() => {\n          _activate();\n        });\n      } else {\n        _activate();\n      }\n    }\n    async _connect() {\n      await this.beforeConnect(this);\n      if (this._stompHandler) {\n        this.debug('There is already a stompHandler, skipping the call to connect');\n        return;\n      }\n      if (!this.active) {\n        this.debug('Client has been marked inactive, will not attempt to connect');\n        return;\n      }\n      // setup connection watcher\n      if (this.connectionTimeout > 0) {\n        // clear first\n        if (this._connectionWatcher) {\n          clearTimeout(this._connectionWatcher);\n        }\n        this._connectionWatcher = setTimeout(() => {\n          if (this.connected) {\n            return;\n          }\n          // Connection not established, close the underlying socket\n          // a reconnection will be attempted\n          this.debug(`Connection not established in ${this.connectionTimeout}ms, closing socket`);\n          this.forceDisconnect();\n        }, this.connectionTimeout);\n      }\n      this.debug('Opening Web Socket...');\n      // Get the actual WebSocket (or a similar object)\n      const webSocket = this._createWebSocket();\n      this._stompHandler = new StompHandler(this, webSocket, {\n        debug: this.debug,\n        stompVersions: this.stompVersions,\n        connectHeaders: this.connectHeaders,\n        disconnectHeaders: this._disconnectHeaders,\n        heartbeatIncoming: this.heartbeatIncoming,\n        heartbeatOutgoing: this.heartbeatOutgoing,\n        heartbeatStrategy: this.heartbeatStrategy,\n        splitLargeFrames: this.splitLargeFrames,\n        maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n        forceBinaryWSFrames: this.forceBinaryWSFrames,\n        logRawCommunication: this.logRawCommunication,\n        appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n        discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n        onConnect: frame => {\n          // Successfully connected, stop the connection watcher\n          if (this._connectionWatcher) {\n            clearTimeout(this._connectionWatcher);\n            this._connectionWatcher = undefined;\n          }\n          if (!this.active) {\n            this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n            this._disposeStompHandler();\n            return;\n          }\n          this.onConnect(frame);\n        },\n        onDisconnect: frame => {\n          this.onDisconnect(frame);\n        },\n        onStompError: frame => {\n          this.onStompError(frame);\n        },\n        onWebSocketClose: evt => {\n          this._stompHandler = undefined; // a new one will be created in case of a reconnect\n          if (this.state === exports.ActivationState.DEACTIVATING) {\n            // Mark deactivation complete\n            this._changeState(exports.ActivationState.INACTIVE);\n          }\n          // The callback is called before attempting to reconnect, this would allow the client\n          // to be `deactivated` in the callback.\n          this.onWebSocketClose(evt);\n          if (this.active) {\n            this._schedule_reconnect();\n          }\n        },\n        onWebSocketError: evt => {\n          this.onWebSocketError(evt);\n        },\n        onUnhandledMessage: message => {\n          this.onUnhandledMessage(message);\n        },\n        onUnhandledReceipt: frame => {\n          this.onUnhandledReceipt(frame);\n        },\n        onUnhandledFrame: frame => {\n          this.onUnhandledFrame(frame);\n        }\n      });\n      this._stompHandler.start();\n    }\n    _createWebSocket() {\n      let webSocket;\n      if (this.webSocketFactory) {\n        webSocket = this.webSocketFactory();\n      } else if (this.brokerURL) {\n        webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n      } else {\n        throw new Error('Either brokerURL or webSocketFactory must be provided');\n      }\n      webSocket.binaryType = 'arraybuffer';\n      return webSocket;\n    }\n    _schedule_reconnect() {\n      if (this._nextReconnectDelay > 0) {\n        this.debug(`STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`);\n        this._reconnector = setTimeout(() => {\n          if (this.reconnectTimeMode === exports.ReconnectionTimeMode.EXPONENTIAL) {\n            this._nextReconnectDelay = this._nextReconnectDelay * 2;\n            // Truncated exponential backoff with a set limit unless disabled\n            if (this.maxReconnectDelay !== 0) {\n              this._nextReconnectDelay = Math.min(this._nextReconnectDelay, this.maxReconnectDelay);\n            }\n          }\n          this._connect();\n        }, this._nextReconnectDelay);\n      }\n    }\n    /**\n     * Disconnect if connected and stop auto reconnect loop.\n     * Appropriate callbacks will be invoked if there is an underlying STOMP connection.\n     *\n     * This call is async. It will resolve immediately if there is no underlying active websocket,\n     * otherwise, it will resolve after the underlying websocket is properly disposed of.\n     *\n     * It is not an error to invoke this method more than once.\n     * Each of those would resolve on completion of deactivation.\n     *\n     * To reactivate, you can call [Client#activate]{@link Client#activate}.\n     *\n     * Experimental: pass `force: true` to immediately discard the underlying connection.\n     * This mode will skip both the STOMP and the Websocket shutdown sequences.\n     * In some cases, browsers take a long time in the Websocket shutdown\n     * if the underlying connection had gone stale.\n     * Using this mode can speed up.\n     * When this mode is used, the actual Websocket may linger for a while\n     * and the broker may not realize that the connection is no longer in use.\n     *\n     * It is possible to invoke this method initially without the `force` option\n     * and subsequently, say after a wait, with the `force` option.\n     */\n    async deactivate(options = {}) {\n      const force = options.force || false;\n      const needToDispose = this.active;\n      let retPromise;\n      if (this.state === exports.ActivationState.INACTIVE) {\n        this.debug(`Already INACTIVE, nothing more to do`);\n        return Promise.resolve();\n      }\n      this._changeState(exports.ActivationState.DEACTIVATING);\n      // Reset reconnection timer just to be safe\n      this._nextReconnectDelay = 0;\n      // Clear if a reconnection was scheduled\n      if (this._reconnector) {\n        clearTimeout(this._reconnector);\n        this._reconnector = undefined;\n      }\n      if (this._stompHandler &&\n      // @ts-ignore - if there is a _stompHandler, there is the webSocket\n      this.webSocket.readyState !== exports.StompSocketState.CLOSED) {\n        const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n        // we need to wait for the underlying websocket to close\n        retPromise = new Promise((resolve, reject) => {\n          // @ts-ignore - there is a _stompHandler\n          this._stompHandler.onWebSocketClose = evt => {\n            origOnWebSocketClose(evt);\n            resolve();\n          };\n        });\n      } else {\n        // indicate that auto reconnect loop should terminate\n        this._changeState(exports.ActivationState.INACTIVE);\n        return Promise.resolve();\n      }\n      if (force) {\n        this._stompHandler?.discardWebsocket();\n      } else if (needToDispose) {\n        this._disposeStompHandler();\n      }\n      return retPromise;\n    }\n    /**\n     * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n     * This is different from a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n     * After forcing disconnect, automatic reconnect will be attempted.\n     * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n     */\n    forceDisconnect() {\n      if (this._stompHandler) {\n        this._stompHandler.forceDisconnect();\n      }\n    }\n    _disposeStompHandler() {\n      // Dispose STOMP Handler\n      if (this._stompHandler) {\n        this._stompHandler.dispose();\n      }\n    }\n    /**\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations.\n     *\n     * STOMP protocol specifies and suggests some headers and also allows broker-specific headers.\n     *\n     * `body` must be String.\n     * You will need to covert the payload to string in case it is not string (e.g. JSON).\n     *\n     * To send a binary message body, use `binaryBody` parameter. It should be a\n     * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n     * Sometimes brokers may not support binary frames out of the box.\n     * Please check your broker documentation.\n     *\n     * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n     * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n     * For binary messages, `content-length` header is always added.\n     *\n     * Caution: The broker will, most likely, report an error and disconnect\n     * if the message body has NULL octet(s) and `content-length` header is missing.\n     *\n     * ```javascript\n     *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n     *\n     *        // Only destination is mandatory parameter\n     *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n     *\n     *        // Skip content-length header in the frame to the broker\n     *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n     *\n     *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n     *        // setting content-type header is not mandatory, however a good practice\n     *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n     *                         headers: {'content-type': 'application/octet-stream'}});\n     * ```\n     */\n    publish(params) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.publish(params);\n    }\n    _checkConnection() {\n      if (!this.connected) {\n        throw new TypeError('There is no underlying STOMP connection');\n      }\n    }\n    /**\n     * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n     * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n     * The value (say receipt-id) for this header needs to be unique for each use.\n     * Typically, a sequence, a UUID, a random number or a combination may be used.\n     *\n     * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n     * The operation needs to be matched based on the value of the receipt-id.\n     *\n     * This method allows watching for a receipt and invoking the callback\n     *  when the corresponding receipt has been received.\n     *\n     * The actual {@link IFrame} will be passed as parameter to the callback.\n     *\n     * Example:\n     * ```javascript\n     *        // Subscribing with acknowledgement\n     *        let receiptId = randomText();\n     *\n     *        client.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *\n     *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n     *\n     *\n     *        // Publishing with acknowledgement\n     *        receiptId = randomText();\n     *\n     *        client.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n     * ```\n     */\n    watchForReceipt(receiptId, callback) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.watchForReceipt(receiptId, callback);\n    }\n    /**\n     * Subscribe to a STOMP Broker location. The callback will be invoked for each\n     * received message with the {@link IMessage} as argument.\n     *\n     * Note: The library will generate a unique ID if there is none provided in the headers.\n     *       To use your own ID, pass it using the `headers` argument.\n     *\n     * ```javascript\n     *        callback = function(message) {\n     *        // called when the client receives a STOMP message from the server\n     *          if (message.body) {\n     *            alert(\"got message with body \" + message.body)\n     *          } else {\n     *            alert(\"got empty message\");\n     *          }\n     *        });\n     *\n     *        var subscription = client.subscribe(\"/queue/test\", callback);\n     *\n     *        // Explicit subscription id\n     *        var mySubId = 'my-subscription-id-001';\n     *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n     * ```\n     */\n    subscribe(destination, callback, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      return this._stompHandler.subscribe(destination, callback, headers);\n    }\n    /**\n     * It is preferable to unsubscribe from a subscription by calling\n     * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n     *\n     * ```javascript\n     *        var subscription = client.subscribe(destination, onmessage);\n     *        // ...\n     *        subscription.unsubscribe();\n     * ```\n     *\n     * See: https://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n     */\n    unsubscribe(id, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.unsubscribe(id, headers);\n    }\n    /**\n     * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\n     * and [abort]{@link ITransaction#abort}.\n     *\n     * `transactionId` is optional, if not passed the library will generate it internally.\n     */\n    begin(transactionId) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      return this._stompHandler.begin(transactionId);\n    }\n    /**\n     * Commit a transaction.\n     *\n     * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\n     * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n     *\n     * ```javascript\n     *        var tx = client.begin(txId);\n     *        //...\n     *        tx.commit();\n     * ```\n     */\n    commit(transactionId) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.commit(transactionId);\n    }\n    /**\n     * Abort a transaction.\n     * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\n     * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n     *\n     * ```javascript\n     *        var tx = client.begin(txId);\n     *        //...\n     *        tx.abort();\n     * ```\n     */\n    abort(transactionId) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.abort(transactionId);\n    }\n    /**\n     * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\n     * on the {@link IMessage} handled by a subscription callback:\n     *\n     * ```javascript\n     *        var callback = function (message) {\n     *          // process the message\n     *          // acknowledge it\n     *          message.ack();\n     *        };\n     *        client.subscribe(destination, callback, {'ack': 'client'});\n     * ```\n     */\n    ack(messageId, subscriptionId, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.ack(messageId, subscriptionId, headers);\n    }\n    /**\n     * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\n     * on the {@link IMessage} handled by a subscription callback:\n     *\n     * ```javascript\n     *        var callback = function (message) {\n     *          // process the message\n     *          // an error occurs, nack it\n     *          message.nack();\n     *        };\n     *        client.subscribe(destination, callback, {'ack': 'client'});\n     * ```\n     */\n    nack(messageId, subscriptionId, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.nack(messageId, subscriptionId, headers);\n    }\n  }\n\n  /**\n   * Configuration options for STOMP Client, each key corresponds to\n   * field by the same name in {@link Client}. This can be passed to\n   * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class StompConfig {}\n\n  /**\n   * STOMP headers. Many functions calls will accept headers as parameters.\n   * The headers sent by Broker will be available as [IFrame#headers]{@link IFrame#headers}.\n   *\n   * `key` and `value` must be valid strings.\n   * In addition, `key` must not contain `CR`, `LF`, or `:`.\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class StompHeaders {}\n\n  /**\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  class HeartbeatInfo {\n    constructor(client) {\n      this.client = client;\n    }\n    get outgoing() {\n      return this.client.heartbeatOutgoing;\n    }\n    set outgoing(value) {\n      this.client.heartbeatOutgoing = value;\n    }\n    get incoming() {\n      return this.client.heartbeatIncoming;\n    }\n    set incoming(value) {\n      this.client.heartbeatIncoming = value;\n    }\n  }\n\n  /**\n   * Available for backward compatibility, please shift to using {@link Client}.\n   *\n   * **Deprecated**\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * To upgrade, please follow the [Upgrade Guide](https://stomp-js.github.io/guide/stompjs/upgrading-stompjs.html)\n   */\n  class CompatClient extends Client {\n    /**\n     * Available for backward compatibility, please shift to using {@link Client}\n     * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\n     *\n     * **Deprecated**\n     *\n     * @internal\n     */\n    constructor(webSocketFactory) {\n      super();\n      /**\n       * It is no op now. No longer needed. Large packets work out of the box.\n       */\n      this.maxWebSocketFrameSize = 16 * 1024;\n      this._heartbeatInfo = new HeartbeatInfo(this);\n      this.reconnect_delay = 0;\n      this.webSocketFactory = webSocketFactory;\n      // Default from previous version\n      this.debug = (...message) => {\n        console.log(...message);\n      };\n    }\n    _parseConnect(...args) {\n      let closeEventCallback;\n      let connectCallback;\n      let errorCallback;\n      let headers = {};\n      if (args.length < 2) {\n        throw new Error('Connect requires at least 2 arguments');\n      }\n      if (typeof args[1] === 'function') {\n        [headers, connectCallback, errorCallback, closeEventCallback] = args;\n      } else {\n        switch (args.length) {\n          case 6:\n            [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback, headers.host] = args;\n            break;\n          default:\n            [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback] = args;\n        }\n      }\n      return [headers, connectCallback, errorCallback, closeEventCallback];\n    }\n    /**\n     * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\n     *\n     * **Deprecated**\n     *\n     * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n     * version with headers to pass your broker specific options.\n     *\n     * overloads:\n     * - connect(headers, connectCallback)\n     * - connect(headers, connectCallback, errorCallback)\n     * - connect(login, passcode, connectCallback)\n     * - connect(login, passcode, connectCallback, errorCallback)\n     * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n     * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n     *\n     * params:\n     * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\n     * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\n     * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\n     * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\n     * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n     * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\n     * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n     *\n     * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n     */\n    connect(...args) {\n      const out = this._parseConnect(...args);\n      if (out[0]) {\n        this.connectHeaders = out[0];\n      }\n      if (out[1]) {\n        this.onConnect = out[1];\n      }\n      if (out[2]) {\n        this.onStompError = out[2];\n      }\n      if (out[3]) {\n        this.onWebSocketClose = out[3];\n      }\n      super.activate();\n    }\n    /**\n     * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\n     *\n     * **Deprecated**\n     *\n     * See:\n     * [Client#onDisconnect]{@link Client#onDisconnect}, and\n     * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\n     *\n     * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n     */\n    disconnect(disconnectCallback, headers = {}) {\n      if (disconnectCallback) {\n        this.onDisconnect = disconnectCallback;\n      }\n      this.disconnectHeaders = headers;\n      super.deactivate();\n    }\n    /**\n     * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\n     *\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations. The headers will, typically, be available to the subscriber.\n     * However, there may be special purpose headers corresponding to your STOMP broker.\n     *\n     *  **Deprecated**, use [Client#publish]{@link Client#publish}\n     *\n     * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n     *\n     * ```javascript\n     *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n     *\n     *        // If you want to send a message with a body, you must also pass the headers argument.\n     *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n     * ```\n     *\n     * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n     */\n    send(destination, headers = {}, body = '') {\n      headers = Object.assign({}, headers);\n      const skipContentLengthHeader = headers['content-length'] === false;\n      if (skipContentLengthHeader) {\n        delete headers['content-length'];\n      }\n      this.publish({\n        destination,\n        headers: headers,\n        body,\n        skipContentLengthHeader\n      });\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\n     *\n     * **Deprecated**\n     */\n    set reconnect_delay(value) {\n      this.reconnectDelay = value;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\n     *\n     * **Deprecated**\n     */\n    get ws() {\n      return this.webSocket;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\n     *\n     * **Deprecated**\n     */\n    get version() {\n      return this.connectedVersion;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n     *\n     * **Deprecated**\n     */\n    get onreceive() {\n      return this.onUnhandledMessage;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n     *\n     * **Deprecated**\n     */\n    set onreceive(value) {\n      this.onUnhandledMessage = value;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n     * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\n     *\n     * **Deprecated**\n     */\n    get onreceipt() {\n      return this.onUnhandledReceipt;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n     *\n     * **Deprecated**\n     */\n    set onreceipt(value) {\n      this.onUnhandledReceipt = value;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n     * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n     *\n     * **Deprecated**\n     */\n    get heartbeat() {\n      return this._heartbeatInfo;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n     * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n     *\n     * **Deprecated**\n     */\n    set heartbeat(value) {\n      this.heartbeatIncoming = value.incoming;\n      this.heartbeatOutgoing = value.outgoing;\n    }\n  }\n\n  /**\n   * STOMP Class, acts like a factory to create {@link Client}.\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * **Deprecated**\n   *\n   * It will be removed in next major version. Please switch to {@link Client}.\n   */\n  class Stomp {\n    /**\n     * This method creates a WebSocket client that is connected to\n     * the STOMP server located at the url.\n     *\n     * ```javascript\n     *        var url = \"ws://localhost:61614/stomp\";\n     *        var client = Stomp.client(url);\n     * ```\n     *\n     * **Deprecated**\n     *\n     * It will be removed in next major version. Please switch to {@link Client}\n     * using [Client#brokerURL]{@link Client#brokerURL}.\n     */\n    static client(url, protocols) {\n      // This is a hack to allow another implementation than the standard\n      // HTML5 WebSocket class.\n      //\n      // It is possible to use another class by calling\n      //\n      //     Stomp.WebSocketClass = MozWebSocket\n      //\n      // *prior* to call `Stomp.client()`.\n      //\n      // This hack is deprecated and `Stomp.over()` method should be used\n      // instead.\n      // See remarks on the function Stomp.over\n      if (protocols == null) {\n        protocols = Versions.default.protocolVersions();\n      }\n      const wsFn = () => {\n        const klass = Stomp.WebSocketClass || WebSocket;\n        return new klass(url, protocols);\n      };\n      return new CompatClient(wsFn);\n    }\n    /**\n     * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\n     * specify the WebSocket to use (either a standard HTML5 WebSocket or\n     * a similar object).\n     *\n     * In order to support reconnection, the function Client._connect should be callable more than once.\n     * While reconnecting\n     * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n     * alternatively allows passing a function that should return a new instance of the underlying socket.\n     *\n     * ```javascript\n     *        var client = Stomp.over(function(){\n     *          return new WebSocket('ws://localhost:15674/ws')\n     *        });\n     * ```\n     *\n     * **Deprecated**\n     *\n     * It will be removed in next major version. Please switch to {@link Client}\n     * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n     */\n    static over(ws) {\n      let wsFn;\n      if (typeof ws === 'function') {\n        wsFn = ws;\n      } else {\n        console.warn('Stomp.over did not receive a factory, auto reconnect will not work. ' + 'Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over');\n        wsFn = () => ws;\n      }\n      return new CompatClient(wsFn);\n    }\n  }\n  /**\n   * In case you need to use a non standard class for WebSocket.\n   *\n   * For example when using within NodeJS environment:\n   *\n   * ```javascript\n   *        StompJs = require('../../esm5/');\n   *        Stomp = StompJs.Stomp;\n   *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\n   * ```\n   *\n   * **Deprecated**\n   *\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  // tslint:disable-next-line:variable-name\n  Stomp.WebSocketClass = null;\n  exports.Client = Client;\n  exports.CompatClient = CompatClient;\n  exports.FrameImpl = FrameImpl;\n  exports.Parser = Parser;\n  exports.Stomp = Stomp;\n  exports.StompConfig = StompConfig;\n  exports.StompHeaders = StompHeaders;\n  exports.Versions = Versions;\n});","map":{"version":3,"names":["augmentWebsocket","webSocket","debug","terminate","noOp","onerror","onmessage","onopen","ts","Date","id","Math","random","toString","substring","origOnClose","onclose","closeEvent","delay","getTime","code","reason","close","call","wasClean","BYTE","LF","NULL","FrameImpl","body","_body","isBinaryBody","TextDecoder","decode","_binaryBody","binaryBody","TextEncoder","encode","constructor","params","command","headers","escapeHeaderValues","skipContentLengthHeader","Object","assign","fromRawFrame","rawFrame","trim","str","replace","header","reverse","indexOf","key","value","hdrValueUnEscape","serializeCmdAndHeaders","serialize","cmdAndHeaders","toUnit8Array","buffer","lines","name","keys","push","hdrValueEscape","isBodyEmpty","bodyLength","join","length","sizeOfUTF8","s","uint8CmdAndHeaders","nullTerminator","Uint8Array","uint8Frame","set","marshall","frame","CR","COLON","Parser","onFrame","onIncomingPing","_encoder","_decoder","_token","_initState","parseChunk","segment","appendMissingNULLonIncoming","chunk","chunkWithNull","i","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_setupCollectBody","_collectHeaderKey","_headerKey","_collectHeaderValue","undefined","contentLengthHeader","filter","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","_consumeTokenAsRaw","e","console","log","rawResult","exports","StompSocketState","ActivationState","ReconnectionTimeMode","TickerStrategy","Ticker","_interval","_strategy","Interval","_debug","_workerScript","start","tick","stop","shouldUseWorker","runWorker","runInterval","disposeWorker","disposeInterval","Worker","_worker","URL","createObjectURL","Blob","type","message","data","_timer","startTime","now","setInterval","clearInterval","Versions","versions","supportedVersions","protocolVersions","map","x","V1_0","V1_1","V1_2","default","StompHandler","connectedVersion","_connectedVersion","connected","_connected","_client","_webSocket","config","_serverFrameHandlers","CONNECTED","server","version","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","client","messageId","ack","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","stompVersions","connectHeaders","disconnectHeaders","heartbeatIncoming","heartbeatOutgoing","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","logRawCommunication","discardWebsocketOnCommFailure","onDisconnect","onWebSocketClose","onWebSocketError","onUnhandledFrame","parser","serverFrameHandler","evt","rawChunkAsString","ArrayBuffer","url","_cleanUp","errorEvent","_transmit","serverOutgoing","serverIncoming","split","v","ttl","max","_pinger","heartbeatStrategy","readyState","OPEN","send","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocket","_closeWebsocket","forceDisconnect","CONNECTING","msg","rawChunk","out","dispose","receipt","watchForReceipt","error","publish","destination","hdrs","receiptId","subscribe","unsubscribe","begin","transactionId","txId","transaction","commit","abort","subscriptionId","Client","_stompHandler","_disconnectHeaders","active","state","ACTIVE","_changeState","onChangeState","conf","connectionTimeout","reconnectDelay","_nextReconnectDelay","maxReconnectDelay","reconnectTimeMode","LINEAR","INACTIVE","beforeConnect","configure","activate","_activate","_connect","DEACTIVATING","deactivate","then","_connectionWatcher","clearTimeout","setTimeout","_createWebSocket","_disposeStompHandler","_schedule_reconnect","webSocketFactory","brokerURL","WebSocket","Error","binaryType","_reconnector","EXPONENTIAL","min","options","force","needToDispose","retPromise","Promise","resolve","CLOSED","origOnWebSocketClose","reject","_checkConnection","TypeError","StompConfig","StompHeaders","HeartbeatInfo","outgoing","incoming","CompatClient","maxWebSocketFrameSize","_heartbeatInfo","reconnect_delay","_parseConnect","args","closeEventCallback","connectCallback","errorCallback","login","passcode","host","connect","disconnect","disconnectCallback","ws","onreceive","onreceipt","heartbeat","Stomp","protocols","wsFn","klass","WebSocketClass","over","warn"],"sources":["C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\augment-websocket.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\byte.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\frame-impl.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\parser.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\types.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\ticker.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\versions.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\stomp-handler.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\client.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\stomp-config.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\stomp-headers.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\compatibility\\heartbeat-info.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\compatibility\\compat-client.ts","C:\\Users\\Win 10\\Desktop\\berberApp - Kopya\\frontend\\node_modules\\@stomp\\stompjs\\src\\compatibility\\stomp.ts"],"sourcesContent":["import { IStompSocket } from './types.js';\n\n/**\n * @internal\n */\nexport function augmentWebsocket(\n  webSocket: IStompSocket,\n  debug: (msg: string) => void\n) {\n  webSocket.terminate = function () {\n    const noOp = () => {};\n\n    // set all callbacks to no op\n    this.onerror = noOp;\n    this.onmessage = noOp;\n    this.onopen = noOp;\n\n    const ts = new Date();\n    const id = Math.random().toString().substring(2, 8); // A simulated id\n\n    const origOnClose = this.onclose;\n\n    // Track delay in actual closure of the socket\n    this.onclose = closeEvent => {\n      const delay = new Date().getTime() - ts.getTime();\n      debug(\n        `Discarded socket (#${id})  closed after ${delay}ms, with code/reason: ${closeEvent.code}/${closeEvent.reason}`\n      );\n    };\n\n    this.close();\n\n    origOnClose?.call(webSocket, {\n      code: 4001,\n      reason: `Quick discarding socket (#${id}) without waiting for the shutdown sequence.`,\n      wasClean: false,\n    });\n  };\n}\n","/**\n * Some byte values, used as per STOMP specifications.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport const BYTE = {\n  // LINEFEED byte (octet 10)\n  LF: '\\x0A',\n  // NULL byte (octet 0)\n  NULL: '\\x00',\n};\n","import { BYTE } from './byte.js';\nimport type { IFrame } from './i-frame.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { IRawFrameType } from './types.js';\n\n/**\n * Frame class represents a STOMP frame.\n *\n * @internal\n */\nexport class FrameImpl implements IFrame {\n  /**\n   * STOMP Command\n   */\n  public command: string;\n\n  /**\n   * Headers, key value pairs.\n   */\n  public headers: StompHeaders;\n\n  /**\n   * Is this frame binary (based on whether body/binaryBody was passed when creating this frame).\n   */\n  public isBinaryBody: boolean;\n\n  /**\n   * body of the frame\n   */\n  get body(): string {\n    if (!this._body && this.isBinaryBody) {\n      this._body = new TextDecoder().decode(this._binaryBody);\n    }\n    return this._body || '';\n  }\n  private _body: string | undefined;\n\n  /**\n   * body as Uint8Array\n   */\n  get binaryBody(): Uint8Array {\n    if (!this._binaryBody && !this.isBinaryBody) {\n      this._binaryBody = new TextEncoder().encode(this._body);\n    }\n    // At this stage it will definitely have a valid value\n    return this._binaryBody as Uint8Array;\n  }\n  private _binaryBody: Uint8Array | undefined;\n\n  private escapeHeaderValues: boolean;\n  private skipContentLengthHeader: boolean;\n\n  /**\n   * Frame constructor. `command`, `headers` and `body` are available as properties.\n   *\n   * @internal\n   */\n  constructor(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    escapeHeaderValues?: boolean;\n    skipContentLengthHeader?: boolean;\n  }) {\n    const {\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues,\n      skipContentLengthHeader,\n    } = params;\n    this.command = command;\n    this.headers = (Object as any).assign({}, headers || {});\n\n    if (binaryBody) {\n      this._binaryBody = binaryBody;\n      this.isBinaryBody = true;\n    } else {\n      this._body = body || '';\n      this.isBinaryBody = false;\n    }\n    this.escapeHeaderValues = escapeHeaderValues || false;\n    this.skipContentLengthHeader = skipContentLengthHeader || false;\n  }\n\n  /**\n   * deserialize a STOMP Frame from raw data.\n   *\n   * @internal\n   */\n  public static fromRawFrame(\n    rawFrame: IRawFrameType,\n    escapeHeaderValues: boolean\n  ): FrameImpl {\n    const headers: StompHeaders = {};\n    const trim = (str: string): string => str.replace(/^\\s+|\\s+$/g, '');\n\n    // In case of repeated headers, as per standards, first value need to be used\n    for (const header of rawFrame.headers.reverse()) {\n      const idx = header.indexOf(':');\n\n      const key = trim(header[0]);\n      let value = trim(header[1]);\n\n      if (\n        escapeHeaderValues &&\n        rawFrame.command !== 'CONNECT' &&\n        rawFrame.command !== 'CONNECTED'\n      ) {\n        value = FrameImpl.hdrValueUnEscape(value);\n      }\n\n      headers[key] = value;\n    }\n\n    return new FrameImpl({\n      command: rawFrame.command as string,\n      headers,\n      binaryBody: rawFrame.binaryBody,\n      escapeHeaderValues,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  public toString(): string {\n    return this.serializeCmdAndHeaders();\n  }\n\n  /**\n   * serialize this Frame in a format suitable to be passed to WebSocket.\n   * If the body is string the output will be string.\n   * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n   *\n   * @internal\n   */\n  public serialize(): string | ArrayBuffer {\n    const cmdAndHeaders = this.serializeCmdAndHeaders();\n\n    if (this.isBinaryBody) {\n      return FrameImpl.toUnit8Array(\n        cmdAndHeaders,\n        this._binaryBody as Uint8Array\n      ).buffer;\n    } else {\n      return cmdAndHeaders + this._body + BYTE.NULL;\n    }\n  }\n\n  private serializeCmdAndHeaders(): string {\n    const lines = [this.command];\n    if (this.skipContentLengthHeader) {\n      delete this.headers['content-length'];\n    }\n\n    for (const name of Object.keys(this.headers || {})) {\n      const value = this.headers[name];\n      if (\n        this.escapeHeaderValues &&\n        this.command !== 'CONNECT' &&\n        this.command !== 'CONNECTED'\n      ) {\n        lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\n      } else {\n        lines.push(`${name}:${value}`);\n      }\n    }\n    if (\n      this.isBinaryBody ||\n      (!this.isBodyEmpty() && !this.skipContentLengthHeader)\n    ) {\n      lines.push(`content-length:${this.bodyLength()}`);\n    }\n    return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n  }\n\n  private isBodyEmpty(): boolean {\n    return this.bodyLength() === 0;\n  }\n\n  private bodyLength(): number {\n    const binaryBody = this.binaryBody;\n    return binaryBody ? binaryBody.length : 0;\n  }\n\n  /**\n   * Compute the size of a UTF-8 string by counting its number of bytes\n   * (and not the number of characters composing the string)\n   */\n  private static sizeOfUTF8(s: string): number {\n    return s ? new TextEncoder().encode(s).length : 0;\n  }\n\n  private static toUnit8Array(\n    cmdAndHeaders: string,\n    binaryBody: Uint8Array\n  ): Uint8Array {\n    const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n    const nullTerminator = new Uint8Array([0]);\n    const uint8Frame = new Uint8Array(\n      uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length\n    );\n\n    uint8Frame.set(uint8CmdAndHeaders);\n    uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n    uint8Frame.set(\n      nullTerminator,\n      uint8CmdAndHeaders.length + binaryBody.length\n    );\n\n    return uint8Frame;\n  }\n  /**\n   * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n   *\n   * @internal\n   */\n  public static marshall(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    escapeHeaderValues?: boolean;\n    skipContentLengthHeader?: boolean;\n  }) {\n    const frame = new FrameImpl(params);\n    return frame.serialize();\n  }\n\n  /**\n   *  Escape header values\n   */\n  private static hdrValueEscape(str: string): string {\n    return str\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/:/g, '\\\\c');\n  }\n\n  /**\n   * UnEscape header values\n   */\n  private static hdrValueUnEscape(str: string): string {\n    return str\n      .replace(/\\\\r/g, '\\r')\n      .replace(/\\\\n/g, '\\n')\n      .replace(/\\\\c/g, ':')\n      .replace(/\\\\\\\\/g, '\\\\');\n  }\n}\n","import { IRawFrameType } from './types.js';\n\n/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\nconst LF = 10;\n/**\n * @internal\n */\nconst CR = 13;\n/**\n * @internal\n */\nconst COLON = 58;\n\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class Parser {\n  private readonly _encoder = new TextEncoder();\n  private readonly _decoder = new TextDecoder();\n\n  // @ts-ignore - it always has a value\n  private _results: IRawFrameType;\n\n  private _token: number[] = [];\n  private _headerKey: string | undefined;\n  private _bodyBytesRemaining: number | undefined;\n\n  // @ts-ignore - it always has a value\n  private _onByte: (byte: number) => void;\n\n  public constructor(\n    public onFrame: (rawFrame: IRawFrameType) => void,\n    public onIncomingPing: () => void\n  ) {\n    this._initState();\n  }\n\n  public parseChunk(\n    segment: string | ArrayBuffer,\n    appendMissingNULLonIncoming: boolean = false\n  ) {\n    let chunk: Uint8Array;\n\n    if (typeof segment === 'string') {\n      chunk = this._encoder.encode(segment);\n    } else {\n      chunk = new Uint8Array(segment);\n    }\n\n    // See https://github.com/stomp-js/stompjs/issues/89\n    // Remove when underlying issue is fixed.\n    //\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\n      chunkWithNull.set(chunk, 0);\n      chunkWithNull[chunk.length] = 0;\n      chunk = chunkWithNull;\n    }\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n      this._onByte(byte);\n    }\n  }\n\n  // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n\n  private _collectFrame(byte: number): void {\n    if (byte === NULL) {\n      // Ignore\n      return;\n    }\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n\n    this._onByte = this._collectCommand;\n    this._reinjectByte(byte);\n  }\n\n  private _collectCommand(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaders(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._setupCollectBody();\n      return;\n    }\n    this._onByte = this._collectHeaderKey;\n    this._reinjectByte(byte);\n  }\n\n  private _reinjectByte(byte: number) {\n    this._onByte(byte);\n  }\n\n  private _collectHeaderKey(byte: number): void {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaderValue(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.headers.push([\n        this._headerKey as string,\n        this._consumeTokenAsUTF8(),\n      ]);\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter(\n      (header: [string, string]) => {\n        return header[0] === 'content-length';\n      }\n    )[0];\n\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n\n  private _collectBodyNullTerminated(byte: number): void {\n    if (byte === NULL) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectBodyFixedSize(byte: number): void {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if ((this._bodyBytesRemaining as number)-- === 0) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n\n    try {\n      this.onFrame(this._results);\n    } catch (e) {\n      console.log(\n        `Ignoring an exception thrown by a frame handler. Original exception: `,\n        e\n      );\n    }\n\n    this._initState();\n  }\n\n  // Rec Descent Parser helpers\n\n  private _consumeByte(byte: number) {\n    this._token.push(byte);\n  }\n\n  private _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n\n  private _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n\n  private _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined,\n    };\n\n    this._token = [];\n    this._headerKey = undefined;\n\n    this._onByte = this._collectFrame;\n  }\n}\n","import type { IFrame } from './i-frame.js';\nimport type { IMessage } from './i-message.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { Versions } from './versions.js';\n\n/**\n * This callback will receive a `string` as a parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type debugFnType = (msg: string) => void;\n\n/**\n * This callback will receive a {@link IMessage} as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type messageCallbackType = (message: IMessage) => void;\n\n/**\n * This callback will receive a {@link IFrame} as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type frameCallbackType = ((frame: IFrame) => void) | (() => void);\n\n/**\n * This callback will receive a [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n * as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type closeEventCallbackType<T = any> = (evt: T) => void;\n\n/**\n * This callback will receive an [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\n * as parameter.\n *\n * Part of `@stomp/stompjs`.\n */\nexport type wsErrorCallbackType<T = any> = (evt: T) => void;\n\n/**\n * Parameters for [Client#publish]{@link Client#publish}.\n * Aliased as publishParams as well.\n *\n * Part of `@stomp/stompjs`.\n */\nexport interface IPublishParams {\n  /**\n   * destination end point\n   */\n  destination: string;\n  /**\n   * headers (optional)\n   */\n  headers?: StompHeaders;\n  /**\n   * body (optional)\n   */\n  body?: string;\n  /**\n   * binary body (optional)\n   */\n  binaryBody?: Uint8Array;\n  /**\n   * By default, a `content-length` header will be added in the Frame to the broker.\n   * Set it to `true` for the header to be skipped.\n   */\n  skipContentLengthHeader?: boolean;\n}\n\n/**\n * Backward compatibility, switch to {@link IPublishParams}.\n */\nexport type publishParams = IPublishParams;\n\n/**\n * Used in {@link IRawFrameType}\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport type RawHeaderType = [string, string];\n\n/**\n * The parser yield frames in this structure\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport interface IRawFrameType {\n  command: string | undefined;\n  headers: RawHeaderType[];\n  binaryBody: Uint8Array | undefined;\n}\n\n/**\n * @internal\n */\nexport interface IStompSocketMessageEvent {\n  data?: string | ArrayBuffer;\n}\n\n/**\n * Copied from Websocket interface to avoid dom typelib dependency.\n *\n * @internal\n */\nexport interface IStompSocket {\n  url: string;\n  onclose: ((ev?: any) => any) | undefined | null;\n  onerror: ((ev: any) => any) | undefined | null;\n  onmessage: ((ev: IStompSocketMessageEvent) => any) | undefined | null;\n  onopen: ((ev?: any) => any) | undefined | null;\n  terminate?: (() => any) | undefined | null;\n\n  /**\n   * Returns a string that indicates how binary data from the socket is exposed to scripts:\n   * We support only 'arraybuffer'.\n   */\n  binaryType?: string;\n\n  /**\n   * Returns the state of the socket connection. It can have the values of StompSocketState.\n   */\n  readonly readyState: number;\n\n  /**\n   * Closes the connection.\n   */\n  close(): void;\n  /**\n   * Transmits data using the connection. data can be a string or an ArrayBuffer.\n   */\n  send(data: string | ArrayBuffer): void;\n}\n\n/**\n * Possible states for the IStompSocket\n */\nexport enum StompSocketState {\n  CONNECTING,\n  OPEN,\n  CLOSING,\n  CLOSED,\n}\n\n/**\n * Possible activation state\n */\nexport enum ActivationState {\n  ACTIVE,\n  DEACTIVATING,\n  INACTIVE,\n}\n\n/**\n * Possible reconnection wait time modes\n */\nexport enum ReconnectionTimeMode {\n  LINEAR,\n  EXPONENTIAL\n}\n\n/**\n * Possible ticker strategies for outgoing heartbeat ping\n */\nexport enum TickerStrategy {\n  Interval = 'interval',\n  Worker = 'worker'\n}\n\n/**\n * @internal\n */\nexport interface IStomptHandlerConfig {\n  debug: debugFnType;\n  stompVersions: Versions;\n  connectHeaders: StompHeaders;\n  disconnectHeaders: StompHeaders;\n  heartbeatIncoming: number;\n  heartbeatOutgoing: number;\n  heartbeatStrategy: TickerStrategy;\n  splitLargeFrames: boolean;\n  maxWebSocketChunkSize: number;\n  forceBinaryWSFrames: boolean;\n  logRawCommunication: boolean;\n  appendMissingNULLonIncoming: boolean;\n  discardWebsocketOnCommFailure: boolean;\n  onConnect: frameCallbackType;\n  onDisconnect: frameCallbackType;\n  onStompError: frameCallbackType;\n  onWebSocketClose: closeEventCallbackType;\n  onWebSocketError: wsErrorCallbackType;\n  onUnhandledMessage: messageCallbackType;\n  onUnhandledReceipt: frameCallbackType;\n  onUnhandledFrame: frameCallbackType;\n}\n","import { debugFnType, TickerStrategy } from './types.js';\n\nexport class Ticker {\n  private readonly _workerScript = `\n    var startTime = Date.now();\n    setInterval(function() {\n        self.postMessage(Date.now() - startTime);\n    }, ${this._interval});\n  `;\n\n  private _worker?: Worker;\n  private _timer?: any;\n\n  constructor(\n    private readonly _interval: number,\n    private readonly _strategy = TickerStrategy.Interval,\n    private readonly _debug: debugFnType) {\n  }\n\n  public start(tick: (elapsedTime: number) => void): void {\n    this.stop();\n\n    if (this.shouldUseWorker()) {\n      this.runWorker(tick);\n    } else {\n      this.runInterval(tick);\n    }\n  }\n\n  public stop(): void {\n    this.disposeWorker();\n    this.disposeInterval();\n  }\n\n  private shouldUseWorker(): boolean {\n    return typeof(Worker) !== 'undefined' && this._strategy === TickerStrategy.Worker\n  }\n\n  private runWorker(tick: (elapsedTime: number) => void): void {\n    this._debug('Using runWorker for outgoing pings');\n    if (!this._worker) {\n      this._worker = new Worker(\n        URL.createObjectURL(\n          new Blob([this._workerScript], { type: 'text/javascript' })\n        )\n      );\n      this._worker.onmessage = (message) => tick(message.data);\n    }\n  }\n\n  private runInterval(tick: (elapsedTime: number) => void): void {\n    this._debug('Using runInterval for outgoing pings');\n    if (!this._timer) {\n      const startTime = Date.now();\n      this._timer = setInterval(() => {\n        tick(Date.now() - startTime);\n      }, this._interval);\n    }\n  }\n\n  private disposeWorker(): void {\n    if (this._worker) {\n      this._worker.terminate();\n      delete this._worker;\n      this._debug('Outgoing ping disposeWorker');\n    }\n  }\n\n  private disposeInterval(): void {\n    if (this._timer) {\n      clearInterval(this._timer);\n      delete this._timer;\n      this._debug('Outgoing ping disposeInterval');\n    }\n  }\n}\n","/**\n * Supported STOMP versions\n *\n * Part of `@stomp/stompjs`.\n */\nexport class Versions {\n  /**\n   * Indicates protocol version 1.0\n   */\n  public static V1_0 = '1.0';\n  /**\n   * Indicates protocol version 1.1\n   */\n  public static V1_1 = '1.1';\n  /**\n   * Indicates protocol version 1.2\n   */\n  public static V1_2 = '1.2';\n\n  /**\n   * @internal\n   */\n  public static default = new Versions([\n    Versions.V1_2,\n    Versions.V1_1,\n    Versions.V1_0,\n  ]);\n\n  /**\n   * Takes an array of versions, typical elements '1.2', '1.1', or '1.0'\n   *\n   * You will be creating an instance of this class if you want to override\n   * supported versions to be declared during STOMP handshake.\n   */\n  constructor(public versions: string[]) {}\n\n  /**\n   * Used as part of CONNECT STOMP Frame\n   */\n  public supportedVersions() {\n    return this.versions.join(',');\n  }\n\n  /**\n   * Used while creating a WebSocket\n   */\n  public protocolVersions() {\n    return this.versions.map(x => `v${x.replace('.', '')}.stomp`);\n  }\n}\n","import { augmentWebsocket } from './augment-websocket.js';\nimport { BYTE } from './byte.js';\nimport { Client } from './client.js';\nimport { FrameImpl } from './frame-impl.js';\nimport type { IMessage } from './i-message.js';\nimport { ITransaction } from './i-transaction.js';\nimport { Parser } from './parser.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { StompSubscription } from './stomp-subscription.js';\nimport { Ticker } from './ticker.js';\nimport {\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  IPublishParams,\n  IStompSocket,\n  IStompSocketMessageEvent,\n  IStomptHandlerConfig,\n  messageCallbackType,\n  StompSocketState,\n  wsErrorCallbackType,\n} from './types.js';\nimport { Versions } from './versions.js';\n\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n  public debug: debugFnType;\n\n  public stompVersions: Versions;\n\n  public connectHeaders: StompHeaders;\n\n  public disconnectHeaders: StompHeaders;\n\n  public heartbeatIncoming: number;\n\n  public heartbeatOutgoing: number;\n\n  public onUnhandledMessage: messageCallbackType;\n\n  public onUnhandledReceipt: frameCallbackType;\n\n  public onUnhandledFrame: frameCallbackType;\n\n  public onConnect: frameCallbackType;\n\n  public onDisconnect: frameCallbackType;\n\n  public onStompError: frameCallbackType;\n\n  public onWebSocketClose: closeEventCallbackType;\n\n  public onWebSocketError: wsErrorCallbackType;\n\n  public logRawCommunication: boolean;\n\n  public splitLargeFrames: boolean;\n\n  public maxWebSocketChunkSize: number;\n\n  public forceBinaryWSFrames: boolean;\n\n  public appendMissingNULLonIncoming: boolean;\n\n  public discardWebsocketOnCommFailure: boolean;\n\n  get connectedVersion(): string | undefined {\n    return this._connectedVersion;\n  }\n  private _connectedVersion: string | undefined;\n\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  private _connected: boolean = false;\n\n  private readonly _subscriptions: { [key: string]: messageCallbackType };\n  private readonly _receiptWatchers: { [key: string]: frameCallbackType };\n  private _partialData: string;\n  private _escapeHeaderValues: boolean;\n  private _counter: number;\n  private _pinger?: Ticker;\n  private _ponger: any;\n  private _lastServerActivityTS: number;\n\n  constructor(\n    private _client: Client,\n    public _webSocket: IStompSocket,\n    config: IStomptHandlerConfig\n  ) {\n    // used to index subscribers\n    this._counter = 0;\n\n    // subscription callbacks indexed by subscriber's ID\n    this._subscriptions = {};\n\n    // receipt-watchers indexed by receipts-ids\n    this._receiptWatchers = {};\n\n    this._partialData = '';\n\n    this._escapeHeaderValues = false;\n\n    this._lastServerActivityTS = Date.now();\n\n    this.debug = config.debug;\n    this.stompVersions = config.stompVersions;\n    this.connectHeaders = config.connectHeaders;\n    this.disconnectHeaders = config.disconnectHeaders;\n    this.heartbeatIncoming = config.heartbeatIncoming;\n    this.heartbeatOutgoing = config.heartbeatOutgoing;\n    this.splitLargeFrames = config.splitLargeFrames;\n    this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n    this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n    this.logRawCommunication = config.logRawCommunication;\n    this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n    this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n    this.onConnect = config.onConnect;\n    this.onDisconnect = config.onDisconnect;\n    this.onStompError = config.onStompError;\n    this.onWebSocketClose = config.onWebSocketClose;\n    this.onWebSocketError = config.onWebSocketError;\n    this.onUnhandledMessage = config.onUnhandledMessage;\n    this.onUnhandledReceipt = config.onUnhandledReceipt;\n    this.onUnhandledFrame = config.onUnhandledFrame;\n  }\n\n  public start(): void {\n    const parser = new Parser(\n      // On Frame\n      rawFrame => {\n        const frame = FrameImpl.fromRawFrame(\n          rawFrame,\n          this._escapeHeaderValues\n        );\n\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n        if (!this.logRawCommunication) {\n          this.debug(`<<< ${frame}`);\n        }\n\n        const serverFrameHandler =\n          this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n        serverFrameHandler(frame);\n      },\n      // On Incoming Ping\n      () => {\n        this.debug('<<< PONG');\n      }\n    );\n\n    this._webSocket.onmessage = (evt: IStompSocketMessageEvent) => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      if (this.logRawCommunication) {\n        const rawChunkAsString =\n          evt.data instanceof ArrayBuffer\n            ? new TextDecoder().decode(evt.data)\n            : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n\n      parser.parseChunk(\n        evt.data as string | ArrayBuffer,\n        this.appendMissingNULLonIncoming\n      );\n    };\n\n    this._webSocket.onclose = (closeEvent): void => {\n      this.debug(`Connection closed to ${this._webSocket.url}`);\n      this._cleanUp();\n      this.onWebSocketClose(closeEvent);\n    };\n\n    this._webSocket.onerror = (errorEvent): void => {\n      this.onWebSocketError(errorEvent);\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = (Object as any).assign({}, this.connectHeaders);\n\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [\n        this.heartbeatOutgoing,\n        this.heartbeatIncoming,\n      ].join(',');\n      this._transmit({ command: 'CONNECT', headers: connectHeaders });\n    };\n  }\n\n  private readonly _serverFrameHandlers: {\n    [key: string]: frameCallbackType;\n  } = {\n    // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n    CONNECTED: frame => {\n      this.debug(`connected to server ${frame.headers.server}`);\n      this._connected = true;\n      this._connectedVersion = frame.headers.version;\n      // STOMP version 1.2 needs header values to be escaped\n      if (this._connectedVersion === Versions.V1_2) {\n        this._escapeHeaderValues = true;\n      }\n\n      this._setupHeartbeat(frame.headers);\n      this.onConnect(frame);\n    },\n\n    // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n    MESSAGE: frame => {\n      // the callback is registered when the client calls\n      // `subscribe()`.\n      // If there is no registered subscription for the received message,\n      // the default `onUnhandledMessage` callback is used that the client can set.\n      // This is useful for subscriptions that are automatically created\n      // on the browser side (e.g. [RabbitMQ's temporary\n      // queues](https://www.rabbitmq.com/stomp.html)).\n      const subscription = frame.headers.subscription;\n      const onReceive =\n        this._subscriptions[subscription] || this.onUnhandledMessage;\n\n      // bless the frame to be a Message\n      const message = frame as IMessage;\n\n      const client = this;\n      const messageId =\n        this._connectedVersion === Versions.V1_2\n          ? message.headers.ack\n          : message.headers['message-id'];\n\n      // add `ack()` and `nack()` methods directly to the returned frame\n      // so that a simple call to `message.ack()` can acknowledge the message.\n      message.ack = (headers: StompHeaders = {}): void => {\n        return client.ack(messageId, subscription, headers);\n      };\n      message.nack = (headers: StompHeaders = {}): void => {\n        return client.nack(messageId, subscription, headers);\n      };\n      onReceive(message);\n    },\n\n    // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n    RECEIPT: frame => {\n      const callback = this._receiptWatchers[frame.headers['receipt-id']];\n      if (callback) {\n        callback(frame);\n        // Server will acknowledge only once, remove the callback\n        delete this._receiptWatchers[frame.headers['receipt-id']];\n      } else {\n        this.onUnhandledReceipt(frame);\n      }\n    },\n\n    // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n    ERROR: frame => {\n      this.onStompError(frame);\n    },\n  };\n\n  private _setupHeartbeat(headers: StompHeaders): void {\n    if (\n      headers.version !== Versions.V1_1 &&\n      headers.version !== Versions.V1_2\n    ) {\n      return;\n    }\n\n    // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n    if (!headers['heart-beat']) {\n      return;\n    }\n\n    // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n    const [serverOutgoing, serverIncoming] = headers['heart-beat']\n      .split(',')\n      .map((v: string) => parseInt(v, 10));\n\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl: number = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n\n      this._pinger = new Ticker(ttl, this._client.heartbeatStrategy, this.debug);\n      this._pinger.start(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n          this.debug('>>> PING');\n        }\n      });\n    }\n\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl: number = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS;\n        // We wait twice the TTL to be flexible on window's setInterval calls\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n\n  private _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug(\n        'Discarding websocket, the underlying socket may linger for a while'\n      );\n      this.discardWebsocket();\n    } else {\n      this.debug('Issuing close on the websocket');\n      this._closeWebsocket();\n    }\n  }\n\n  public forceDisconnect() {\n    if (this._webSocket) {\n      if (\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\n        this._webSocket.readyState === StompSocketState.OPEN\n      ) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n\n  public _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n    this._webSocket.close();\n  }\n\n  public discardWebsocket() {\n    if (typeof this._webSocket.terminate !== 'function') {\n      augmentWebsocket(this._webSocket, (msg: string) => this.debug(msg));\n    }\n\n    // @ts-ignore - this method will be there at this stage\n    this._webSocket.terminate();\n  }\n\n  private _transmit(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    skipContentLengthHeader?: boolean;\n  }): void {\n    const { command, headers, body, binaryBody, skipContentLengthHeader } =\n      params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader,\n    });\n\n    let rawChunk = frame.serialize();\n\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk as string;\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n        this._webSocket.send(chunk);\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n\n  public dispose(): void {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = (Object as any).assign(\n          {},\n          this.disconnectHeaders\n        );\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n          this._cleanUp();\n          this.onDisconnect(frame);\n        });\n        this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\n        this._webSocket.readyState === StompSocketState.OPEN\n      ) {\n        this._closeWebsocket();\n      }\n    }\n  }\n\n  private _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      this._pinger.stop();\n      this._pinger = undefined;\n    }\n    if (this._ponger) {\n      clearInterval(this._ponger);\n      this._ponger = undefined;\n    }\n  }\n\n  public publish(params: IPublishParams): void {\n    const { destination, headers, body, binaryBody, skipContentLengthHeader } =\n      params;\n    const hdrs: StompHeaders = (Object as any).assign({ destination }, headers);\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader,\n    });\n  }\n\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  public subscribe(\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ): StompSubscription {\n    headers = (Object as any).assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n    this._transmit({ command: 'SUBSCRIBE', headers });\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      },\n    };\n  }\n\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    headers = (Object as any).assign({}, headers);\n\n    delete this._subscriptions[id];\n    headers.id = id;\n    this._transmit({ command: 'UNSUBSCRIBE', headers });\n  }\n\n  public begin(transactionId: string): ITransaction {\n    const txId = transactionId || `tx-${this._counter++}`;\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId,\n      },\n    });\n    const client = this;\n    return {\n      id: txId,\n      commit(): void {\n        client.commit(txId);\n      },\n      abort(): void {\n        client.abort(txId);\n      },\n    };\n  }\n\n  public commit(transactionId: string): void {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId,\n      },\n    });\n  }\n\n  public abort(transactionId: string): void {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId,\n      },\n    });\n  }\n\n  public ack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    this._transmit({ command: 'ACK', headers });\n  }\n\n  public nack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    return this._transmit({ command: 'NACK', headers });\n  }\n}\n","import { ITransaction } from './i-transaction.js';\nimport { StompConfig } from './stomp-config.js';\nimport { StompHandler } from './stomp-handler.js';\nimport { StompHeaders } from './stomp-headers.js';\nimport { StompSubscription } from './stomp-subscription.js';\nimport {\n  ActivationState,\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  IPublishParams,\n  IStompSocket,\n  messageCallbackType,\n  ReconnectionTimeMode,\n  StompSocketState,\n  TickerStrategy,\n  wsErrorCallbackType,\n} from './types.js';\nimport { Versions } from './versions.js';\n\n/**\n * @internal\n */\ndeclare const WebSocket: {\n  prototype: IStompSocket;\n  new (url: string, protocols?: string | string[]): IStompSocket;\n};\n\n/**\n * STOMP Client Class.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class Client {\n  /**\n   * The URL for the STOMP broker to connect to.\n   * Typically like `\"ws://broker.329broker.com:15674/ws\"` or `\"wss://broker.329broker.com:15674/ws\"`.\n   *\n   * Only one of this or [Client#webSocketFactory]{@link Client#webSocketFactory} need to be set.\n   * If both are set, [Client#webSocketFactory]{@link Client#webSocketFactory} will be used.\n   *\n   * If your environment does not support WebSockets natively, please refer to\n   * [Polyfills]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}.\n   */\n  public brokerURL: string | undefined;\n\n  /**\n   * STOMP versions to attempt during STOMP handshake. By default, versions `1.2`, `1.1`, and `1.0` are attempted.\n   *\n   * Example:\n   * ```javascript\n   *        // Try only versions 1.1 and 1.0\n   *        client.stompVersions = new Versions(['1.1', '1.0'])\n   * ```\n   */\n  public stompVersions = Versions.default;\n\n  /**\n   * This function should return a WebSocket or a similar (e.g. SockJS) object.\n   * If your environment does not support WebSockets natively, please refer to\n   * [Polyfills]{@link https://stomp-js.github.io/guide/stompjs/rx-stomp/ng2-stompjs/pollyfils-for-stompjs-v5.html}.\n   * If your STOMP Broker supports WebSockets, prefer setting [Client#brokerURL]{@link Client#brokerURL}.\n   *\n   * If both this and [Client#brokerURL]{@link Client#brokerURL} are set, this will be used.\n   *\n   * Example:\n   * ```javascript\n   *        // use a WebSocket\n   *        client.webSocketFactory= function () {\n   *          return new WebSocket(\"wss://broker.329broker.com:15674/ws\");\n   *        };\n   *\n   *        // Typical usage with SockJS\n   *        client.webSocketFactory= function () {\n   *          return new SockJS(\"http://broker.329broker.com/stomp\");\n   *        };\n   * ```\n   */\n  public webSocketFactory: (() => IStompSocket) | undefined;\n\n  /**\n   * Will retry if Stomp connection is not established in specified milliseconds.\n   * Default 0, which switches off automatic reconnection.\n   */\n  public connectionTimeout: number = 0;\n\n  // As per https://stackoverflow.com/questions/45802988/typescript-use-correct-version-of-settimeout-node-vs-window/56239226#56239226\n  private _connectionWatcher: ReturnType<typeof setTimeout> | undefined; // Timer\n\n  /**\n   *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n   */\n  public reconnectDelay: number = 5000;\n\n  /**\n   * tracking the time to the next reconnection. Initialized to [Client#reconnectDelay]{@link Client#reconnectDelay}'s value and it may\n   * change depending on the [Client#reconnectTimeMode]{@link Client#reconnectTimeMode} setting\n   */\n  private _nextReconnectDelay: number = 0;\n\n  /**\n   * Maximum time to wait between reconnects, in milliseconds. Defaults to 15 minutes.\n   * Only relevant when [Client#reconnectTimeMode]{@link Client#reconnectTimeMode} not LINEAR (e.g., EXPONENTIAL).\n   * Set to 0 for no limit on wait time.\n   */\n  public maxReconnectDelay: number = 15 * 60 * 1000; // 15 minutes in ms\n\n  /**\n   * Reconnection wait time mode, either linear (default) or exponential.\n   * Note: See [Client#maxReconnectDelay]{@link Client#maxReconnectDelay} for setting the maximum delay when exponential\n   *\n   * ```javascript\n   * client.configure({\n   *   reconnectTimeMode: ReconnectionTimeMode.EXPONENTIAL,\n   *   reconnectDelay: 200, // It will wait 200, 400, 800 ms...\n   *   maxReconnectDelay: 10000, // Optional, when provided, it will not wait more that these ms\n   * })\n   * ```\n   */\n  public reconnectTimeMode: ReconnectionTimeMode = ReconnectionTimeMode.LINEAR;\n\n  /**\n   * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n   */\n  public heartbeatIncoming: number = 10000;\n\n  /**\n   * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n   */\n  public heartbeatOutgoing: number = 10000;\n\n  /**\n   * Outgoing heartbeat strategy.\n   * See https://github.com/stomp-js/stompjs/pull/579\n   *\n   * Can be worker or interval strategy, but will always use `interval`\n   * if web workers are unavailable, for example, in a non-browser environment.\n   *\n   * Using Web Workers may work better on long-running pages\n   * and mobile apps, as the browser may suspend Timers in the main page.\n   * Try the `Worker` mode if you discover disconnects when the browser tab is in the background.\n   *\n   * When used in a JS environment, use 'worker' or 'interval' as valid values.\n   *\n   * Defaults to `interval` strategy.\n   */\n  public heartbeatStrategy: TickerStrategy = TickerStrategy.Interval;\n\n  /**\n   * This switches on a non-standard behavior while sending WebSocket packets.\n   * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n   * Only Java Spring brokers seem to support this mode.\n   *\n   * WebSockets, by itself, split large (text) packets,\n   * so it is not needed with a truly compliant STOMP/WebSocket broker.\n   * Setting it for such a broker will cause large messages to fail.\n   *\n   * `false` by default.\n   *\n   * Binary frames are never split.\n   */\n  public splitLargeFrames: boolean = false;\n\n  /**\n   * See [splitLargeFrames]{@link Client#splitLargeFrames}.\n   * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n   */\n  public maxWebSocketChunkSize: number = 8 * 1024;\n\n  /**\n   * Usually the\n   * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\n   * is automatically decided by type of the payload.\n   * Default is `false`, which should work with all compliant brokers.\n   *\n   * Set this flag to force binary frames.\n   */\n  public forceBinaryWSFrames: boolean = false;\n\n  /**\n   * A bug in ReactNative chops a string on occurrence of a NULL.\n   * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\n   * This makes incoming WebSocket messages invalid STOMP packets.\n   * Setting this flag attempts to reverse the damage by appending a NULL.\n   * If the broker splits a large message into multiple WebSocket messages,\n   * this flag will cause data loss and abnormal termination of connection.\n   *\n   * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\n   */\n  public appendMissingNULLonIncoming: boolean = false;\n\n  /**\n   * Underlying WebSocket instance, READONLY.\n   */\n  get webSocket(): IStompSocket | undefined {\n    return this._stompHandler?._webSocket;\n  }\n\n  /**\n   * Connection headers, important keys - `login`, `passcode`, `host`.\n   * Though STOMP 1.2 standard marks these keys to be present, check your broker documentation for\n   * details specific to your broker.\n   */\n  public connectHeaders: StompHeaders;\n\n  /**\n   * Disconnection headers.\n   */\n  get disconnectHeaders(): StompHeaders {\n    return this._disconnectHeaders;\n  }\n\n  set disconnectHeaders(value: StompHeaders) {\n    this._disconnectHeaders = value;\n    if (this._stompHandler) {\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n    }\n  }\n  private _disconnectHeaders: StompHeaders;\n\n  /**\n   * This function will be called for any unhandled messages.\n   * It is useful for receiving messages sent to RabbitMQ temporary queues.\n   *\n   * It can also get invoked with stray messages while the server is processing\n   * a request to [Client#unsubscribe]{@link Client#unsubscribe}\n   * from an endpoint.\n   *\n   * The actual {@link IMessage} will be passed as parameter to the callback.\n   */\n  public onUnhandledMessage: messageCallbackType;\n\n  /**\n   * STOMP brokers can be requested to notify when an operation is actually completed.\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}. See\n   * [Client#watchForReceipt]{@link Client#watchForReceipt} for examples.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   */\n  public onUnhandledReceipt: frameCallbackType;\n\n  /**\n   * Will be invoked if {@link IFrame} of an unknown type is received from the STOMP broker.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   */\n  public onUnhandledFrame: frameCallbackType;\n\n  /**\n   * `true` if there is an active connection to STOMP Broker\n   */\n  get connected(): boolean {\n    return !!this._stompHandler && this._stompHandler.connected;\n  }\n\n  /**\n   * Callback, invoked on before a connection to the STOMP broker.\n   *\n   * You can change options on the client, which will impact the immediate connecting.\n   * It is valid to call [Client#decativate]{@link Client#deactivate} in this callback.\n   *\n   * As of version 5.1, this callback can be\n   * [async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\n   * (i.e., it can return a\n   * [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)).\n   * In that case, connect will be called only after the Promise is resolved.\n   * This can be used to reliably fetch credentials, access token etc. from some other service\n   * in an asynchronous way.\n   */\n  public beforeConnect: (client: Client) => void | Promise<void>;\n\n  /**\n   * Callback, invoked on every successful connection to the STOMP broker.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   * Sometimes clients will like to use headers from this frame.\n   */\n  public onConnect: frameCallbackType;\n\n  /**\n   * Callback, invoked on every successful disconnection from the STOMP broker. It will not be invoked if\n   * the STOMP broker disconnected due to an error.\n   *\n   * The actual Receipt {@link IFrame} acknowledging the DISCONNECT will be passed as parameter to the callback.\n   *\n   * The way STOMP protocol is designed, the connection may close/terminate without the client\n   * receiving the Receipt {@link IFrame} acknowledging the DISCONNECT.\n   * You might find [Client#onWebSocketClose]{@link Client#onWebSocketClose} more appropriate to watch\n   * STOMP broker disconnects.\n   */\n  public onDisconnect: frameCallbackType;\n\n  /**\n   * Callback, invoked on an ERROR frame received from the STOMP Broker.\n   * A compliant STOMP Broker will close the connection after this type of frame.\n   * Please check broker specific documentation for exact behavior.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   */\n  public onStompError: frameCallbackType;\n\n  /**\n   * Callback, invoked when underlying WebSocket is closed.\n   *\n   * Actual [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   * is passed as parameter to the callback.\n   */\n  public onWebSocketClose: closeEventCallbackType;\n\n  /**\n   * Callback, invoked when underlying WebSocket raises an error.\n   *\n   * Actual [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\n   * is passed as parameter to the callback.\n   */\n  public onWebSocketError: wsErrorCallbackType;\n\n  /**\n   * Set it to log the actual raw communication with the broker.\n   * When unset, it logs headers of the parsed frames.\n   *\n   * Changes effect from the next broker reconnect.\n   *\n   * **Caution: this assumes that frames only have valid UTF8 strings.**\n   */\n  public logRawCommunication: boolean;\n\n  /**\n   * By default, debug messages are discarded. To log to `console` following can be used:\n   *\n   * ```javascript\n   *        client.debug = function(str) {\n   *          console.log(str);\n   *        };\n   * ```\n   *\n   * Currently this method does not support levels of log. Be aware that the\n   * output can be quite verbose\n   * and may contain sensitive information (like passwords, tokens etc.).\n   */\n  public debug: debugFnType;\n\n  /**\n   * Browsers do not immediately close WebSockets when `.close` is issued.\n   * This may cause reconnection to take a significantly long time in case\n   *  of some types of failures.\n   * In case of incoming heartbeat failure, this experimental flag instructs\n   * the library to discard the socket immediately\n   * (even before it is actually closed).\n   */\n  public discardWebsocketOnCommFailure: boolean = false;\n\n  /**\n   * version of STOMP protocol negotiated with the server, READONLY\n   */\n  get connectedVersion(): string | undefined {\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n  }\n\n  private _stompHandler: StompHandler | undefined;\n\n  /**\n   * if the client is active (connected or going to reconnect)\n   */\n  get active(): boolean {\n    return this.state === ActivationState.ACTIVE;\n  }\n\n  /**\n   * It will be called on state change.\n   *\n   * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n   */\n  public onChangeState: (state: ActivationState) => void;\n\n  private _changeState(state: ActivationState) {\n    this.state = state;\n    this.onChangeState(state);\n  }\n\n  /**\n   * Activation state.\n   *\n   * It will usually be ACTIVE or INACTIVE.\n   * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n   */\n  public state: ActivationState = ActivationState.INACTIVE;\n\n  private _reconnector: any;\n\n  /**\n   * Create an instance.\n   */\n  constructor(conf: StompConfig = {}) {\n    // No op callbacks\n    const noOp = () => {};\n    this.debug = noOp;\n    this.beforeConnect = noOp;\n    this.onConnect = noOp;\n    this.onDisconnect = noOp;\n    this.onUnhandledMessage = noOp;\n    this.onUnhandledReceipt = noOp;\n    this.onUnhandledFrame = noOp;\n    this.onStompError = noOp;\n    this.onWebSocketClose = noOp;\n    this.onWebSocketError = noOp;\n    this.logRawCommunication = false;\n    this.onChangeState = noOp;\n\n    // These parameters would typically get proper values before connect is called\n    this.connectHeaders = {};\n    this._disconnectHeaders = {};\n\n    // Apply configuration\n    this.configure(conf);\n  }\n\n  /**\n   * Update configuration.\n   */\n  public configure(conf: StompConfig): void {\n    // bulk assign all properties to this\n    (Object as any).assign(this, conf);\n\n    // Warn on incorrect maxReconnectDelay settings\n    if (\n      this.maxReconnectDelay > 0 &&\n      this.maxReconnectDelay < this.reconnectDelay\n    ) {\n      this.debug(\n        `Warning: maxReconnectDelay (${this.maxReconnectDelay}ms) is less than reconnectDelay (${this.reconnectDelay}ms). Using reconnectDelay as the maxReconnectDelay delay.`,\n      );\n      this.maxReconnectDelay = this.reconnectDelay;\n    }\n  }\n\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n   * it will keep trying to reconnect. If the [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}\n   * is set to EXPONENTIAL it will increase the wait time exponentially\n   *\n   * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n   */\n  public activate(): void {\n    const _activate = () => {\n      if (this.active) {\n        this.debug('Already ACTIVE, ignoring request to activate');\n        return;\n      }\n\n      this._changeState(ActivationState.ACTIVE);\n\n      this._nextReconnectDelay = this.reconnectDelay;\n      this._connect();\n    };\n\n    // if it is deactivating, wait for it to complete before activating.\n    if (this.state === ActivationState.DEACTIVATING) {\n      this.debug('Waiting for deactivation to finish before activating');\n      this.deactivate().then(() => {\n        _activate();\n      });\n    } else {\n      _activate();\n    }\n  }\n\n  private async _connect(): Promise<void> {\n    await this.beforeConnect(this);\n\n    if (this._stompHandler) {\n      this.debug(\n        'There is already a stompHandler, skipping the call to connect',\n      );\n      return;\n    }\n\n    if (!this.active) {\n      this.debug(\n        'Client has been marked inactive, will not attempt to connect',\n      );\n      return;\n    }\n\n    // setup connection watcher\n    if (this.connectionTimeout > 0) {\n      // clear first\n      if (this._connectionWatcher) {\n        clearTimeout(this._connectionWatcher);\n      }\n      this._connectionWatcher = setTimeout(() => {\n        if (this.connected) {\n          return;\n        }\n        // Connection not established, close the underlying socket\n        // a reconnection will be attempted\n        this.debug(\n          `Connection not established in ${this.connectionTimeout}ms, closing socket`,\n        );\n        this.forceDisconnect();\n      }, this.connectionTimeout);\n    }\n\n    this.debug('Opening Web Socket...');\n\n    // Get the actual WebSocket (or a similar object)\n    const webSocket = this._createWebSocket();\n\n    this._stompHandler = new StompHandler(this, webSocket, {\n      debug: this.debug,\n      stompVersions: this.stompVersions,\n      connectHeaders: this.connectHeaders,\n      disconnectHeaders: this._disconnectHeaders,\n      heartbeatIncoming: this.heartbeatIncoming,\n      heartbeatOutgoing: this.heartbeatOutgoing,\n      heartbeatStrategy: this.heartbeatStrategy,\n      splitLargeFrames: this.splitLargeFrames,\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\n      logRawCommunication: this.logRawCommunication,\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n      discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n\n      onConnect: frame => {\n        // Successfully connected, stop the connection watcher\n        if (this._connectionWatcher) {\n          clearTimeout(this._connectionWatcher);\n          this._connectionWatcher = undefined;\n        }\n\n        if (!this.active) {\n          this.debug(\n            'STOMP got connected while deactivate was issued, will disconnect now',\n          );\n          this._disposeStompHandler();\n          return;\n        }\n        this.onConnect(frame);\n      },\n      onDisconnect: frame => {\n        this.onDisconnect(frame);\n      },\n      onStompError: frame => {\n        this.onStompError(frame);\n      },\n      onWebSocketClose: evt => {\n        this._stompHandler = undefined; // a new one will be created in case of a reconnect\n\n        if (this.state === ActivationState.DEACTIVATING) {\n          // Mark deactivation complete\n          this._changeState(ActivationState.INACTIVE);\n        }\n\n        // The callback is called before attempting to reconnect, this would allow the client\n        // to be `deactivated` in the callback.\n        this.onWebSocketClose(evt);\n\n        if (this.active) {\n          this._schedule_reconnect();\n        }\n      },\n      onWebSocketError: evt => {\n        this.onWebSocketError(evt);\n      },\n      onUnhandledMessage: message => {\n        this.onUnhandledMessage(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.onUnhandledReceipt(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.onUnhandledFrame(frame);\n      },\n    });\n\n    this._stompHandler.start();\n  }\n\n  private _createWebSocket(): IStompSocket {\n    let webSocket: IStompSocket;\n\n    if (this.webSocketFactory) {\n      webSocket = this.webSocketFactory();\n    } else if (this.brokerURL) {\n      webSocket = new WebSocket(\n        this.brokerURL,\n        this.stompVersions.protocolVersions(),\n      );\n    } else {\n      throw new Error('Either brokerURL or webSocketFactory must be provided');\n    }\n    webSocket.binaryType = 'arraybuffer';\n    return webSocket;\n  }\n\n  private _schedule_reconnect(): void {\n    if (this._nextReconnectDelay > 0) {\n      this.debug(\n        `STOMP: scheduling reconnection in ${this._nextReconnectDelay}ms`,\n      );\n\n      this._reconnector = setTimeout(() => {\n        if (this.reconnectTimeMode === ReconnectionTimeMode.EXPONENTIAL) {\n          this._nextReconnectDelay = this._nextReconnectDelay * 2;\n\n          // Truncated exponential backoff with a set limit unless disabled\n          if (this.maxReconnectDelay !== 0) {\n            this._nextReconnectDelay = Math.min(\n              this._nextReconnectDelay,\n              this.maxReconnectDelay,\n            );\n          }\n        }\n\n        this._connect();\n      }, this._nextReconnectDelay);\n    }\n  }\n\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if there is an underlying STOMP connection.\n   *\n   * This call is async. It will resolve immediately if there is no underlying active websocket,\n   * otherwise, it will resolve after the underlying websocket is properly disposed of.\n   *\n   * It is not an error to invoke this method more than once.\n   * Each of those would resolve on completion of deactivation.\n   *\n   * To reactivate, you can call [Client#activate]{@link Client#activate}.\n   *\n   * Experimental: pass `force: true` to immediately discard the underlying connection.\n   * This mode will skip both the STOMP and the Websocket shutdown sequences.\n   * In some cases, browsers take a long time in the Websocket shutdown\n   * if the underlying connection had gone stale.\n   * Using this mode can speed up.\n   * When this mode is used, the actual Websocket may linger for a while\n   * and the broker may not realize that the connection is no longer in use.\n   *\n   * It is possible to invoke this method initially without the `force` option\n   * and subsequently, say after a wait, with the `force` option.\n   */\n  public async deactivate(options: { force?: boolean } = {}): Promise<void> {\n    const force: boolean = options.force || false;\n    const needToDispose = this.active;\n    let retPromise: Promise<void>;\n\n    if (this.state === ActivationState.INACTIVE) {\n      this.debug(`Already INACTIVE, nothing more to do`);\n      return Promise.resolve();\n    }\n\n    this._changeState(ActivationState.DEACTIVATING);\n\n    // Reset reconnection timer just to be safe\n    this._nextReconnectDelay = 0;\n\n    // Clear if a reconnection was scheduled\n    if (this._reconnector) {\n      clearTimeout(this._reconnector);\n      this._reconnector = undefined;\n    }\n\n    if (\n      this._stompHandler &&\n      // @ts-ignore - if there is a _stompHandler, there is the webSocket\n      this.webSocket.readyState !== StompSocketState.CLOSED\n    ) {\n      const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n      // we need to wait for the underlying websocket to close\n      retPromise = new Promise<void>((resolve, reject) => {\n        // @ts-ignore - there is a _stompHandler\n        this._stompHandler.onWebSocketClose = evt => {\n          origOnWebSocketClose(evt);\n          resolve();\n        };\n      });\n    } else {\n      // indicate that auto reconnect loop should terminate\n      this._changeState(ActivationState.INACTIVE);\n      return Promise.resolve();\n    }\n\n    if (force) {\n      this._stompHandler?.discardWebsocket();\n    } else if (needToDispose) {\n      this._disposeStompHandler();\n    }\n\n    return retPromise;\n  }\n\n  /**\n   * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n   * This is different from a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n   * After forcing disconnect, automatic reconnect will be attempted.\n   * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n   */\n  public forceDisconnect() {\n    if (this._stompHandler) {\n      this._stompHandler.forceDisconnect();\n    }\n  }\n\n  private _disposeStompHandler() {\n    // Dispose STOMP Handler\n    if (this._stompHandler) {\n      this._stompHandler.dispose();\n    }\n  }\n\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker-specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body, use `binaryBody` parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages, `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect\n   * if the message body has NULL octet(s) and `content-length` header is missing.\n   *\n   * ```javascript\n   *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n  public publish(params: IPublishParams) {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.publish(params);\n  }\n\n  private _checkConnection() {\n    if (!this.connected) {\n      throw new TypeError('There is no underlying STOMP connection');\n    }\n  }\n\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use.\n   * Typically, a sequence, a UUID, a random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based on the value of the receipt-id.\n   *\n   * This method allows watching for a receipt and invoking the callback\n   *  when the corresponding receipt has been received.\n   *\n   * The actual {@link IFrame} will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Subscribing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        client.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *\n   *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n   *\n   *\n   *        // Publishing with acknowledgement\n   *        receiptId = randomText();\n   *\n   *        client.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n   * ```\n   */\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.watchForReceipt(receiptId, callback);\n  }\n\n  /**\n   * Subscribe to a STOMP Broker location. The callback will be invoked for each\n   * received message with the {@link IMessage} as argument.\n   *\n   * Note: The library will generate a unique ID if there is none provided in the headers.\n   *       To use your own ID, pass it using the `headers` argument.\n   *\n   * ```javascript\n   *        callback = function(message) {\n   *        // called when the client receives a STOMP message from the server\n   *          if (message.body) {\n   *            alert(\"got message with body \" + message.body)\n   *          } else {\n   *            alert(\"got empty message\");\n   *          }\n   *        });\n   *\n   *        var subscription = client.subscribe(\"/queue/test\", callback);\n   *\n   *        // Explicit subscription id\n   *        var mySubId = 'my-subscription-id-001';\n   *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n   * ```\n   */\n  public subscribe(\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {},\n  ): StompSubscription {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.subscribe(destination, callback, headers);\n  }\n\n  /**\n   * It is preferable to unsubscribe from a subscription by calling\n   * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n   *\n   * ```javascript\n   *        var subscription = client.subscribe(destination, onmessage);\n   *        // ...\n   *        subscription.unsubscribe();\n   * ```\n   *\n   * See: https://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n   */\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.unsubscribe(id, headers);\n  }\n\n  /**\n   * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\n   * and [abort]{@link ITransaction#abort}.\n   *\n   * `transactionId` is optional, if not passed the library will generate it internally.\n   */\n  public begin(transactionId?: string): ITransaction {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    return this._stompHandler.begin(transactionId);\n  }\n\n  /**\n   * Commit a transaction.\n   *\n   * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\n   * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n   *\n   * ```javascript\n   *        var tx = client.begin(txId);\n   *        //...\n   *        tx.commit();\n   * ```\n   */\n  public commit(transactionId: string): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.commit(transactionId);\n  }\n\n  /**\n   * Abort a transaction.\n   * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\n   * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n   *\n   * ```javascript\n   *        var tx = client.begin(txId);\n   *        //...\n   *        tx.abort();\n   * ```\n   */\n  public abort(transactionId: string): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.abort(transactionId);\n  }\n\n  /**\n   * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\n   * on the {@link IMessage} handled by a subscription callback:\n   *\n   * ```javascript\n   *        var callback = function (message) {\n   *          // process the message\n   *          // acknowledge it\n   *          message.ack();\n   *        };\n   *        client.subscribe(destination, callback, {'ack': 'client'});\n   * ```\n   */\n  public ack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {},\n  ): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.ack(messageId, subscriptionId, headers);\n  }\n\n  /**\n   * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\n   * on the {@link IMessage} handled by a subscription callback:\n   *\n   * ```javascript\n   *        var callback = function (message) {\n   *          // process the message\n   *          // an error occurs, nack it\n   *          message.nack();\n   *        };\n   *        client.subscribe(destination, callback, {'ack': 'client'});\n   * ```\n   */\n  public nack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {},\n  ): void {\n    this._checkConnection();\n    // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n    this._stompHandler.nack(messageId, subscriptionId, headers);\n  }\n}\n","import { StompHeaders } from './stomp-headers.js';\nimport {\n  ActivationState,\n  TickerStrategy,\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  messageCallbackType,\n  ReconnectionTimeMode,\n  wsErrorCallbackType,\n} from './types.js';\nimport { Versions } from './versions.js';\nimport { Client } from './client.js';\n\n/**\n * Configuration options for STOMP Client, each key corresponds to\n * field by the same name in {@link Client}. This can be passed to\n * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class StompConfig {\n  /**\n   * See [Client#brokerURL]{@link Client#brokerURL}.\n   */\n  public brokerURL?: string;\n\n  /**\n   * See [Client#stompVersions]{@link Client#stompVersions}.\n   */\n  public stompVersions?: Versions;\n\n  /**\n   * See [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  public webSocketFactory?: () => any;\n\n  /**\n   * See [Client#connectionTimeout]{@link Client#connectionTimeout}.\n   */\n  public connectionTimeout?: number;\n\n  /**\n   * See [Client#reconnectDelay]{@link Client#reconnectDelay}.\n   */\n  public reconnectDelay?: number;\n\n  /**\n   * See [Client#maxReconnectDelay]{@link Client#maxReconnectDelay}\n   */\n  public maxReconnectDelay?: number;\n\n  /**\n   * See [Client#reconnectTimeMode]{@link Client#reconnectTimeMode}\n   */\n  public reconnectTimeMode?: ReconnectionTimeMode;\n\n  /**\n   * See [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}.\n   */\n  public heartbeatIncoming?: number;\n\n  /**\n   * See [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n   */\n  public heartbeatOutgoing?: number;\n\n  /**\n   * See [Client#heartbeatStrategy]{@link Client#heartbeatStrategy}.\n   */\n  public heartbeatStrategy?: TickerStrategy;\n\n  /**\n   * See [Client#splitLargeFrames]{@link Client#splitLargeFrames}.\n   */\n  public splitLargeFrames?: boolean;\n\n  /**\n   * See [Client#forceBinaryWSFrames]{@link Client#forceBinaryWSFrames}.\n   */\n  public forceBinaryWSFrames?: boolean;\n\n  /**\n   * See [Client#appendMissingNULLonIncoming]{@link Client#appendMissingNULLonIncoming}.\n   */\n  public appendMissingNULLonIncoming?: boolean;\n\n  /**\n   * See [Client#maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n   */\n  public maxWebSocketChunkSize?: number;\n\n  /**\n   * See [Client#connectHeaders]{@link Client#connectHeaders}.\n   */\n  public connectHeaders?: StompHeaders;\n\n  /**\n   * See [Client#disconnectHeaders]{@link Client#disconnectHeaders}.\n   */\n  public disconnectHeaders?: StompHeaders;\n\n  /**\n   * See [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n   */\n  public onUnhandledMessage?: messageCallbackType;\n\n  /**\n   * See [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n   */\n  public onUnhandledReceipt?: frameCallbackType;\n\n  /**\n   * See [Client#onUnhandledFrame]{@link Client#onUnhandledFrame}.\n   */\n  public onUnhandledFrame?: frameCallbackType;\n\n  /**\n   * See [Client#beforeConnect]{@link Client#beforeConnect}.\n   */\n  public beforeConnect?: (client: Client) => void | Promise<void>;\n\n  /**\n   * See [Client#onConnect]{@link Client#onConnect}.\n   */\n  public onConnect?: frameCallbackType;\n\n  /**\n   * See [Client#onDisconnect]{@link Client#onDisconnect}.\n   */\n  public onDisconnect?: frameCallbackType;\n\n  /**\n   * See [Client#onStompError]{@link Client#onStompError}.\n   */\n  public onStompError?: frameCallbackType;\n\n  /**\n   * See [Client#onWebSocketClose]{@link Client#onWebSocketClose}.\n   */\n  public onWebSocketClose?: closeEventCallbackType;\n\n  /**\n   * See [Client#onWebSocketError]{@link Client#onWebSocketError}.\n   */\n  public onWebSocketError?: wsErrorCallbackType;\n\n  /**\n   * See [Client#logRawCommunication]{@link Client#logRawCommunication}.\n   */\n  public logRawCommunication?: boolean;\n\n  /**\n   * See [Client#debug]{@link Client#debug}.\n   */\n  public debug?: debugFnType;\n\n  /**\n   * See [Client#discardWebsocketOnCommFailure]{@link Client#discardWebsocketOnCommFailure}.\n   */\n  public discardWebsocketOnCommFailure?: boolean;\n\n  /**\n   * See [Client#onChangeState]{@link Client#onChangeState}.\n   */\n  public onChangeState?: (state: ActivationState) => void;\n}\n","/**\n * STOMP headers. Many functions calls will accept headers as parameters.\n * The headers sent by Broker will be available as [IFrame#headers]{@link IFrame#headers}.\n *\n * `key` and `value` must be valid strings.\n * In addition, `key` must not contain `CR`, `LF`, or `:`.\n *\n * Part of `@stomp/stompjs`.\n */\nexport class StompHeaders {\n  [key: string]: string;\n}\n","import { CompatClient } from './compat-client.js';\n\n/**\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class HeartbeatInfo {\n  constructor(private client: CompatClient) {}\n\n  get outgoing(): number {\n    return this.client.heartbeatOutgoing;\n  }\n\n  set outgoing(value: number) {\n    this.client.heartbeatOutgoing = value;\n  }\n\n  get incoming(): number {\n    return this.client.heartbeatIncoming;\n  }\n\n  set incoming(value: number) {\n    this.client.heartbeatIncoming = value;\n  }\n}\n","import { Client } from '../client.js';\nimport { StompHeaders } from '../stomp-headers.js';\nimport { frameCallbackType, messageCallbackType } from '../types.js';\nimport { HeartbeatInfo } from './heartbeat-info.js';\n\n/**\n * Available for backward compatibility, please shift to using {@link Client}.\n *\n * **Deprecated**\n *\n * Part of `@stomp/stompjs`.\n *\n * To upgrade, please follow the [Upgrade Guide](https://stomp-js.github.io/guide/stompjs/upgrading-stompjs.html)\n */\nexport class CompatClient extends Client {\n  /**\n   * It is no op now. No longer needed. Large packets work out of the box.\n   */\n  public maxWebSocketFrameSize: number = 16 * 1024;\n\n  /**\n   * Available for backward compatibility, please shift to using {@link Client}\n   * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   *\n   * **Deprecated**\n   *\n   * @internal\n   */\n  constructor(webSocketFactory: () => any) {\n    super();\n    this.reconnect_delay = 0;\n    this.webSocketFactory = webSocketFactory;\n    // Default from previous version\n    this.debug = (...message: any[]) => {\n      console.log(...message);\n    };\n  }\n\n  private _parseConnect(...args: any[]): any {\n    let closeEventCallback;\n    let connectCallback;\n    let errorCallback;\n    let headers: StompHeaders = {};\n    if (args.length < 2) {\n      throw new Error('Connect requires at least 2 arguments');\n    }\n    if (typeof args[1] === 'function') {\n      [headers, connectCallback, errorCallback, closeEventCallback] = args;\n    } else {\n      switch (args.length) {\n        case 6:\n          [\n            headers.login,\n            headers.passcode,\n            connectCallback,\n            errorCallback,\n            closeEventCallback,\n            headers.host,\n          ] = args;\n          break;\n        default:\n          [\n            headers.login,\n            headers.passcode,\n            connectCallback,\n            errorCallback,\n            closeEventCallback,\n          ] = args;\n      }\n    }\n\n    return [headers, connectCallback, errorCallback, closeEventCallback];\n  }\n\n  /**\n   * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\n   *\n   * **Deprecated**\n   *\n   * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n   * version with headers to pass your broker specific options.\n   *\n   * overloads:\n   * - connect(headers, connectCallback)\n   * - connect(headers, connectCallback, errorCallback)\n   * - connect(login, passcode, connectCallback)\n   * - connect(login, passcode, connectCallback, errorCallback)\n   * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n   * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n   *\n   * params:\n   * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\n   * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\n   * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\n   * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\n   * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n   * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\n   * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n   *\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n   */\n  public connect(...args: any[]): void {\n    const out = this._parseConnect(...args);\n\n    if (out[0]) {\n      this.connectHeaders = out[0];\n    }\n    if (out[1]) {\n      this.onConnect = out[1];\n    }\n    if (out[2]) {\n      this.onStompError = out[2];\n    }\n    if (out[3]) {\n      this.onWebSocketClose = out[3];\n    }\n\n    super.activate();\n  }\n\n  /**\n   * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\n   *\n   * **Deprecated**\n   *\n   * See:\n   * [Client#onDisconnect]{@link Client#onDisconnect}, and\n   * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\n   *\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n   */\n  public disconnect(\n    disconnectCallback?: any,\n    headers: StompHeaders = {}\n  ): void {\n    if (disconnectCallback) {\n      this.onDisconnect = disconnectCallback;\n    }\n    this.disconnectHeaders = headers;\n\n    super.deactivate();\n  }\n\n  /**\n   * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\n   *\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations. The headers will, typically, be available to the subscriber.\n   * However, there may be special purpose headers corresponding to your STOMP broker.\n   *\n   *  **Deprecated**, use [Client#publish]{@link Client#publish}\n   *\n   * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n   *\n   * ```javascript\n   *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n   *\n   *        // If you want to send a message with a body, you must also pass the headers argument.\n   *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n   * ```\n   *\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n   */\n  public send(\n    destination: string,\n    headers: { [key: string]: any } = {},\n    body: string = ''\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    const skipContentLengthHeader = headers['content-length'] === false;\n    if (skipContentLengthHeader) {\n      delete headers['content-length'];\n    }\n    this.publish({\n      destination,\n      headers: headers as StompHeaders,\n      body,\n      skipContentLengthHeader,\n    });\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\n   *\n   * **Deprecated**\n   */\n  set reconnect_delay(value: number) {\n    this.reconnectDelay = value;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\n   *\n   * **Deprecated**\n   */\n  get ws(): any {\n    return this.webSocket;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\n   *\n   * **Deprecated**\n   */\n  get version() {\n    return this.connectedVersion;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n   *\n   * **Deprecated**\n   */\n  get onreceive(): messageCallbackType {\n    return this.onUnhandledMessage;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n   *\n   * **Deprecated**\n   */\n  set onreceive(value: messageCallbackType) {\n    this.onUnhandledMessage = value;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\n   *\n   * **Deprecated**\n   */\n  get onreceipt(): frameCallbackType {\n    return this.onUnhandledReceipt;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n   *\n   * **Deprecated**\n   */\n  set onreceipt(value: frameCallbackType) {\n    this.onUnhandledReceipt = value;\n  }\n\n  private _heartbeatInfo: HeartbeatInfo = new HeartbeatInfo(this);\n\n  /**\n   * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n   * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n   *\n   * **Deprecated**\n   */\n  get heartbeat() {\n    return this._heartbeatInfo;\n  }\n\n  /**\n   * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n   * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n   *\n   * **Deprecated**\n   */\n  set heartbeat(value: { incoming: number; outgoing: number }) {\n    this.heartbeatIncoming = value.incoming;\n    this.heartbeatOutgoing = value.outgoing;\n  }\n}\n","import { Versions } from '../versions.js';\nimport { CompatClient } from './compat-client.js';\nimport { IStompSocket } from '../types.js';\n\n/**\n * @internal\n */\ndeclare const WebSocket: {\n  prototype: IStompSocket;\n  new (url: string, protocols?: string | string[]): IStompSocket;\n};\n\n/**\n * STOMP Class, acts like a factory to create {@link Client}.\n *\n * Part of `@stomp/stompjs`.\n *\n * **Deprecated**\n *\n * It will be removed in next major version. Please switch to {@link Client}.\n */\nexport class Stomp {\n  /**\n   * In case you need to use a non standard class for WebSocket.\n   *\n   * For example when using within NodeJS environment:\n   *\n   * ```javascript\n   *        StompJs = require('../../esm5/');\n   *        Stomp = StompJs.Stomp;\n   *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\n   * ```\n   *\n   * **Deprecated**\n   *\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  // tslint:disable-next-line:variable-name\n  public static WebSocketClass: any = null;\n\n  /**\n   * This method creates a WebSocket client that is connected to\n   * the STOMP server located at the url.\n   *\n   * ```javascript\n   *        var url = \"ws://localhost:61614/stomp\";\n   *        var client = Stomp.client(url);\n   * ```\n   *\n   * **Deprecated**\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#brokerURL]{@link Client#brokerURL}.\n   */\n  public static client(url: string, protocols?: string[]): CompatClient {\n    // This is a hack to allow another implementation than the standard\n    // HTML5 WebSocket class.\n    //\n    // It is possible to use another class by calling\n    //\n    //     Stomp.WebSocketClass = MozWebSocket\n    //\n    // *prior* to call `Stomp.client()`.\n    //\n    // This hack is deprecated and `Stomp.over()` method should be used\n    // instead.\n\n    // See remarks on the function Stomp.over\n    if (protocols == null) {\n      protocols = Versions.default.protocolVersions();\n    }\n    const wsFn = () => {\n      const klass = Stomp.WebSocketClass || WebSocket;\n      return new klass(url, protocols);\n    };\n\n    return new CompatClient(wsFn);\n  }\n\n  /**\n   * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\n   * specify the WebSocket to use (either a standard HTML5 WebSocket or\n   * a similar object).\n   *\n   * In order to support reconnection, the function Client._connect should be callable more than once.\n   * While reconnecting\n   * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n   * alternatively allows passing a function that should return a new instance of the underlying socket.\n   *\n   * ```javascript\n   *        var client = Stomp.over(function(){\n   *          return new WebSocket('ws://localhost:15674/ws')\n   *        });\n   * ```\n   *\n   * **Deprecated**\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  public static over(ws: any): CompatClient {\n    let wsFn: () => any;\n\n    if (typeof ws === 'function') {\n      wsFn = ws;\n    } else {\n      console.warn(\n        'Stomp.over did not receive a factory, auto reconnect will not work. ' +\n          'Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over'\n      );\n      wsFn = () => ws;\n    }\n\n    return new CompatClient(wsFn);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}